<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emitter Follower Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
    tailwind.config = {
        theme: {
            extend: {
                colors: {
                    primary: '#2266cc',
                }
            }
        }
    }
    </script>
    <style>
        svg text { font-family: ui-monospace, monospace; }
    </style>
</head>
<body class="max-w-3xl mx-auto px-4 sm:px-6 py-8 font-sans leading-relaxed">
    <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-4">Emitter Follower Calculator</h1>
    <p class="text-gray-600 text-lg max-w-xl mb-6">
        Design a common-collector (emitter follower) buffer amplifier.
        This topology provides near-unity gain with high input impedance and low output impedance -
        ideal for driving low-impedance loads without loading the source.
    </p>

    <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Inputs</h2>
    <div class="overflow-x-auto">
        <table class="w-full sm:w-auto">
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Supply voltage for the amplifier">Vcc:</td>
                <td class="py-2"><input type="number" id="vcc" value="10" step="0.1" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> V</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Peak amplitude of your input signal">Input (peak):</td>
                <td class="py-2"><input type="number" id="vin" value="1" step="0.1" min="0.1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> V</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Output impedance of whatever drives this amplifier. Should be much lower than buffer's Zin.">Source impedance:</td>
                <td class="py-2"><input type="number" id="zsource" value="1000" step="100" min="0" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> &#8486;</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Lowest frequency you need to pass. Sets the coupling capacitor sizes.">Low frequency (-3dB):</td>
                <td class="py-2"><input type="number" id="fLow" value="20" step="1" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> Hz</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Resistance of whatever this amplifier drives. The main reason to use an emitter follower!">Load resistance:</td>
                <td class="py-2"><input type="number" id="rload" value="600" step="100" min="10" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> &#8486;</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="DC current through the emitter. Higher values give lower output impedance but use more power.">Emitter current (Ie):</td>
                <td class="py-2"><input type="number" id="ie" value="5" step="1" min="0.5" max="50" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> mA</td>
            </tr>
        </table>
    </div>

    <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Transistor Selection</h2>
    <div class="overflow-x-auto">
        <table class="w-full sm:w-auto">
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Select a real transistor to see practical limitations, or Ideal for theoretical behavior with infinite β and bandwidth.">Transistor:</td>
                <td class="py-2">
                    <select id="transistorPreset" onchange="updateTransistorFields()" class="px-2 py-1 border border-gray-300 rounded text-sm">
                        <option value="ideal" selected>Ideal</option>
                        <option value="2n2222">2N2222</option>
                        <option value="2n3904">2N3904</option>
                        <option value="bc547">BC547</option>
                        <option value="2n5551">2N5551</option>
                        <option value="mpsa18">MPSA18</option>
                        <option value="custom">Custom...</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Current gain (Ic/Ib). Higher β means less base current needed, higher input impedance.">&#946; (hFE):</td>
                <td class="py-2"><input type="text" id="beta" value="∞" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm bg-gray-100 text-gray-500" disabled></td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Transition frequency - where β drops to 1. Limits high-frequency performance.">fT:</td>
                <td class="py-2"><input type="text" id="ft" value="∞" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm bg-gray-100 text-gray-500" disabled> MHz</td>
            </tr>
        </table>
    </div>
    <p class="text-sm text-gray-400 mt-2">Hover over labels for explanations.</p>
    <div class="flex flex-wrap gap-2 mt-4">
        <button onclick="calculate()" class="px-5 py-2 bg-primary text-white rounded hover:bg-blue-700 cursor-pointer text-sm">Calculate</button>
        <button onclick="resetDefaults()" class="px-5 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 cursor-pointer text-sm">Reset</button>
        <button onclick="openInFalstad()" class="px-5 py-2 bg-green-600 text-white rounded hover:bg-green-700 cursor-pointer text-sm">Open in Falstad</button>
    </div>

    <div id="warning" class="hidden text-red-700 bg-red-50 border-l-4 border-red-600 p-4 my-4"></div>

    <div id="results">
        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Schematic</h2>
        <div id="schematic" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Calculated Values</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            Component values rounded to standard E24 series.
        </p>
        <div class="overflow-x-auto">
            <table class="w-full sm:w-auto">
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Upper bias resistor, sets base voltage together with R2">R1 (upper bias):</td><td id="r1" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Lower bias resistor, forms voltage divider with R1">R2 (lower bias):</td><td id="r2" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Emitter resistor, sets the bias current and contributes to output impedance">Re (emitter):</td><td id="re" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Input coupling capacitor, blocks DC while passing AC signal">Cin (input):</td><td id="cin" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Output coupling capacitor, blocks DC bias from reaching the load">Cout (output):</td><td id="cout" class="py-2 text-right font-mono"></td></tr>
            </table>
        </div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Buffer Performance</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The emitter follower excels at impedance transformation - high Zin, low Zout.
            Gain is slightly less than 1 due to the voltage divider formed by re' and Re.
        </p>
        <div class="overflow-x-auto">
            <table class="w-full sm:w-auto">
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="How much resistance the buffer presents to the signal source. Higher is better for not loading the source.">Input impedance (Zin):</td><td id="zin" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="How much resistance the buffer presents to its load. Lower means it can drive heavier loads.">Output impedance (Zout):</td><td id="zout" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Voltage gain, always slightly less than 1">Voltage gain:</td><td id="gain" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Signal loss at input due to source impedance">Input attenuation:</td><td id="inputAtten" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Overall gain from source to load">Effective gain:</td><td id="effectiveGain" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4">Expected output:</td><td id="expectedOut" class="py-2 text-right font-mono"></td></tr>
            </table>
        </div>

        <p id="note" class="text-amber-600 mt-4"></p>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Input / Output Waveforms</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The emitter follower has no phase inversion - output follows input (hence the name).
            Clipping occurs if output exceeds the available swing.
        </p>
        <div id="waveforms" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">DC Load Line</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The load line shows the operating path. For an emitter follower, the DC load is just Re
            (collector connects directly to Vcc).
        </p>
        <div id="loadLine" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Frequency Response</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            Low frequencies are limited by coupling capacitors (Cin, Cout).
            High frequencies are limited by the transistor's &#946; rolloff at f&#946; = fT/&#946;.
            The emitter follower has minimal Miller effect since voltage gain is near unity.
        </p>
        <div id="freqResponse" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Design Formulas</h2>
        <details class="my-4">
            <summary class="cursor-pointer text-primary font-bold">Click to show step-by-step design procedure</summary>
            <div class="mt-4 p-4 bg-gray-100 rounded text-sm">
                <h3 class="text-base font-semibold text-gray-600 mt-0 mb-2">Step 1: Choose Emitter Current</h3>
                <p>Higher current = lower output impedance, but more power dissipation:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    I<sub>E</sub> chosen based on load requirements<br>
                    Rule of thumb: I<sub>E</sub> > 10 &#215; (V<sub>out</sub> / R<sub>load</sub>)
                </code>
                <div id="calc-step1" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 2: Calculate Emitter Resistor</h3>
                <p>Set Ve at roughly half of Vcc for maximum swing:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    V<sub>E</sub> &#8776; V<sub>CC</sub> / 2<br>
                    R<sub>E</sub> = V<sub>E</sub> / I<sub>E</sub>
                </code>
                <div id="calc-step2" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 3: Calculate Intrinsic Emitter Resistance</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    r<sub>e</sub>' = 26mV / I<sub>E</sub> = 0.026 / I<sub>E</sub>
                </code>
                <div id="calc-step3" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 4: Calculate Bias Resistors</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    V<sub>B</sub> = V<sub>E</sub> + 0.7V<br>
                    I<sub>B</sub> = I<sub>E</sub> / &#946;<br>
                    I<sub>divider</sub> = 10 &#215; I<sub>B</sub><br>
                    R<sub>total</sub> = V<sub>CC</sub> / I<sub>divider</sub><br>
                    R<sub>2</sub> = (V<sub>B</sub> / V<sub>CC</sub>) &#215; R<sub>total</sub><br>
                    R<sub>1</sub> = R<sub>total</sub> - R<sub>2</sub>
                </code>
                <div id="calc-step4" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 5: Calculate Voltage Gain</h3>
                <p>Gain is slightly less than 1:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    A<sub>v</sub> = (R<sub>E</sub> &#8741; R<sub>load</sub>) / (r<sub>e</sub>' + R<sub>E</sub> &#8741; R<sub>load</sub>)<br>
                    A<sub>v</sub> &#8776; 0.95 to 0.99 typically
                </code>
                <div id="calc-step5" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 6: Calculate Input Impedance</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    Z<sub>in(base)</sub> = &#946; &#215; (r<sub>e</sub>' + R<sub>E</sub> &#8741; R<sub>load</sub>)<br>
                    Z<sub>in</sub> = R<sub>1</sub> &#8741; R<sub>2</sub> &#8741; Z<sub>in(base)</sub>
                </code>
                <div id="calc-step6" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 7: Calculate Output Impedance</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    Z<sub>out</sub> = (r<sub>e</sub>' + R<sub>source</sub>/&#946;) &#8741; R<sub>E</sub><br>
                    For low R<sub>source</sub>: Z<sub>out</sub> &#8776; r<sub>e</sub>' &#8741; R<sub>E</sub> &#8776; r<sub>e</sub>'
                </code>
                <div id="calc-step7" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 8: Calculate Coupling Capacitors</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    C<sub>in</sub> = 1 / (2&#960; &#215; f<sub>low</sub> &#215; Z<sub>in</sub>)<br>
                    C<sub>out</sub> = 1 / (2&#960; &#215; f<sub>low</sub> &#215; R<sub>load</sub>)
                </code>
                <div id="calc-step8" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Key Characteristics</h3>
                <ul class="list-disc ml-5 space-y-1">
                    <li><b>Voltage gain:</b> A<sub>v</sub> &#8776; 1 (unity gain buffer)</li>
                    <li><b>Current gain:</b> A<sub>i</sub> &#8776; &#946; (high)</li>
                    <li><b>Power gain:</b> A<sub>p</sub> &#8776; &#946; (significant)</li>
                    <li><b>Input impedance:</b> High (&#946; &#215; R<sub>E</sub>)</li>
                    <li><b>Output impedance:</b> Low (&#8776; r<sub>e</sub>')</li>
                    <li><b>Phase shift:</b> 0&#176; (no inversion)</li>
                </ul>
            </div>
        </details>
    </div>

    <script src="../common.js"></script>
    <script src="../schematic.js"></script>
    <script src="../graph.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <script>
        let lastCalcValues = null;

        function storeCalcValues(vals) {
            lastCalcValues = vals;
        }

        function updateDesignSteps(params) {
            const { vcc, ve, vb, ie, re, reRounded, reIntrinsic, rload, vin,
                    beta, ib, idivider, rtotal, r1, r2, r1Rounded, r2Rounded,
                    reParallelRload, gain, zinBase, zin, zsource, zoutBase, zout,
                    fLow, fcorner, cinCalc, cinRounded, coutCalc, coutRounded,
                    inputAtten, effectiveGain } = params;

            // Step 1: Choose Emitter Current
            const iLoadPeak = vin * gain / rload;
            const ieMin = 10 * iLoadPeak;
            const ieCheck = ie > ieMin ? '✓ OK' : '✗ May need more current';
            document.getElementById('calc-step1').innerHTML =
                `I<sub>E</sub> = <b>${(ie*1000).toFixed(2)} mA</b> (chosen)<br>` +
                `Rule check: I<sub>E</sub> > 10 × (${(vin*1000).toFixed(0)}mV × ${gain.toFixed(3)} / ${fmtLong(rload, 'Ω')}) = ${(ieMin*1000).toFixed(2)}mA? <b>${ieCheck}</b>`;

            // Step 2: Emitter Resistor
            document.getElementById('calc-step2').innerHTML =
                `V<sub>E</sub> = ${vcc}V / 2 = <b>${ve.toFixed(2)}V</b><br>` +
                `R<sub>E</sub> = ${ve.toFixed(2)}V / ${(ie*1000).toFixed(2)}mA = ${re.toFixed(1)}Ω → <b>${fmtLong(reRounded, 'Ω')}</b> (E24)`;

            // Step 3: Intrinsic Emitter Resistance
            document.getElementById('calc-step3').innerHTML =
                `r<sub>e</sub>' = 26mV / ${(ie*1000).toFixed(2)}mA = <b>${reIntrinsic.toFixed(2)}Ω</b>`;

            // Step 4: Bias Resistors
            document.getElementById('calc-step4').innerHTML =
                `V<sub>B</sub> = ${ve.toFixed(2)}V + 0.7V = <b>${vb.toFixed(2)}V</b><br>` +
                `I<sub>B</sub> = ${(ie*1000).toFixed(2)}mA / ${beta} = ${(ib*1e6).toFixed(2)}µA<br>` +
                `I<sub>divider</sub> = 10 × ${(ib*1e6).toFixed(2)}µA = ${(idivider*1e6).toFixed(1)}µA<br>` +
                `R<sub>total</sub> = ${vcc}V / ${(idivider*1e6).toFixed(1)}µA = ${(rtotal/1000).toFixed(1)}kΩ<br>` +
                `R<sub>2</sub> = (${vb.toFixed(2)}V / ${vcc}V) × ${(rtotal/1000).toFixed(1)}kΩ = ${(r2/1000).toFixed(2)}kΩ → <b>${fmtLong(r2Rounded, 'Ω')}</b><br>` +
                `R<sub>1</sub> = ${(rtotal/1000).toFixed(1)}kΩ - ${(r2/1000).toFixed(2)}kΩ = ${(r1/1000).toFixed(2)}kΩ → <b>${fmtLong(r1Rounded, 'Ω')}</b>`;

            // Step 5: Voltage Gain
            document.getElementById('calc-step5').innerHTML =
                `R<sub>E</sub> ∥ R<sub>load</sub> = ${fmtLong(reRounded, 'Ω')} ∥ ${fmtLong(rload, 'Ω')} = ${fmtLong(reParallelRload, 'Ω')}<br>` +
                `A<sub>v</sub> = ${fmtLong(reParallelRload, 'Ω')} / (${reIntrinsic.toFixed(2)}Ω + ${fmtLong(reParallelRload, 'Ω')}) = <b>${gain.toFixed(4)}</b> (${(gain*100).toFixed(1)}%)`;

            // Step 6: Input Impedance
            document.getElementById('calc-step6').innerHTML =
                `Z<sub>in(base)</sub> = ${beta} × (${reIntrinsic.toFixed(2)}Ω + ${fmtLong(reParallelRload, 'Ω')}) = ${fmtLong(zinBase, 'Ω')}<br>` +
                `Z<sub>in</sub> = ${fmtLong(r1Rounded, 'Ω')} ∥ ${fmtLong(r2Rounded, 'Ω')} ∥ ${fmtLong(zinBase, 'Ω')} = <b>${fmtLong(zin, 'Ω')}</b>`;

            // Step 7: Output Impedance
            document.getElementById('calc-step7').innerHTML =
                `Z<sub>out(base)</sub> = ${reIntrinsic.toFixed(2)}Ω + ${fmtLong(zsource, 'Ω')}/${beta} = ${reIntrinsic.toFixed(2)}Ω + ${(zsource/beta).toFixed(2)}Ω = ${fmtLong(zoutBase, 'Ω')}<br>` +
                `Z<sub>out</sub> = ${fmtLong(zoutBase, 'Ω')} ∥ ${fmtLong(reRounded, 'Ω')} = <b>${fmtLong(zout, 'Ω')}</b>`;

            // Step 8: Coupling Capacitors
            document.getElementById('calc-step8').innerHTML =
                `<i>Using f<sub>corner</sub> = f<sub>low</sub>/10 = ${fcorner.toFixed(1)}Hz for margin:</i><br>` +
                `C<sub>in</sub> = 1 / (2π × ${fcorner.toFixed(1)}Hz × ${fmtLong(zin, 'Ω')}) = ${fmtLong(cinCalc, 'F')} → <b>${fmtLong(cinRounded, 'F')}</b><br>` +
                `C<sub>out</sub> = 1 / (2π × ${fcorner.toFixed(1)}Hz × ${fmtLong(rload, 'Ω')}) = ${fmtLong(coutCalc, 'F')} → <b>${fmtLong(coutRounded, 'F')}</b>`;
        }

        function openInFalstad() {
            if (!lastCalcValues) {
                alert('Please calculate first');
                return;
            }
            const v = lastCalcValues;
            const beta = v.beta;

            // Falstad circuit format - all coordinates on 16px grid
            // Layout:
            //   Vcc at top (y=48)
            //   R1 from Vcc to base junction (x=176)
            //   Collector connects directly to Vcc (x=256)
            //   Transistor body at x=256
            //   R2 from base junction to ground
            //   Re from emitter to ground

            const lines = [
                // Header
                `$ 1 0.000005 10.20027730826997 ${v.vcc * 2} 5 50 5e-11`,

                // Vcc power rail
                `R 256 48 256 16 0 0 40 ${v.vcc} 0 0 0.5`,

                // R1 (upper bias) - from Vcc rail to base junction
                `r 176 48 176 144 0 ${v.r1}`,

                // R2 (lower bias) - from base junction to ground
                `r 176 144 176 240 0 ${v.r2}`,

                // Ground under R2
                `g 176 240 176 256 0`,

                // Wire from Vcc to R1
                `w 256 48 176 48 0`,

                // NPN Transistor - base at (224, 144), body center at (256, 144)
                // Collector at (256, 128), Emitter at (256, 160)
                `t 224 144 256 144 0 1 -0.6 0.5 ${beta}`,

                // Wire from base junction to transistor base
                `w 176 144 224 144 0`,

                // Wire from Vcc to collector (emitter follower - collector ties to Vcc)
                `w 256 48 256 128 0`,

                // Re (emitter resistor) - from emitter to ground
                `r 256 160 256 240 0 ${v.re}`,

                // Ground under Re
                `g 256 240 256 256 0`,

                // Input AC source
                `R 80 144 48 144 0 1 1000 ${v.vinPeak} 0 0 0.5`,

                // Cin (input coupling cap)
                `c 80 144 128 144 0 ${v.cin} 0`,

                // Wire from Cin to base junction
                `w 128 144 176 144 0`,

                // Cout (output coupling cap) - from emitter node to output
                `c 304 160 352 160 0 ${v.cout} 0`,

                // Wire from emitter to Cout
                `w 256 160 304 160 0`,

                // Rload
                `r 352 160 352 240 0 ${v.rload}`,

                // Ground under Rload
                `g 352 240 352 256 0`,

                // Output probe
                `p 352 160 400 160 1 0 0`,

                // Scope on output (element 17 = probe)
                `o 17 8 0 4099 5 0.05 0 2 17 3`,
            ];

            const circuitText = lines.join('\n');
            const compressed = LZString.compressToEncodedURIComponent(circuitText);
            const url = `https://www.falstad.com/circuit/circuitjs.html?ctz=${compressed}`;
            window.open(url, '_blank');
        }

        function updateTransistorFields() {
            const preset = document.getElementById('transistorPreset').value;
            const isCustom = preset === 'custom';
            const betaEl = document.getElementById('beta');
            const ftEl = document.getElementById('ft');

            // Enable/disable fields based on custom selection
            betaEl.disabled = !isCustom;
            ftEl.disabled = !isCustom;

            // Update field styling
            betaEl.classList.toggle('bg-gray-100', !isCustom);
            betaEl.classList.toggle('text-gray-500', !isCustom);
            ftEl.classList.toggle('bg-gray-100', !isCustom);
            ftEl.classList.toggle('text-gray-500', !isCustom);

            // Populate values from preset
            if (preset === 'ideal') {
                betaEl.value = '100';
                ftEl.value = '300';
            } else if (preset !== 'custom' && typeof BJT_PRESETS !== 'undefined' && BJT_PRESETS[preset]) {
                const p = BJT_PRESETS[preset];
                betaEl.value = p.beta;
                ftEl.value = (p.ft / 1e6).toFixed(0);
            }
        }

        function getTransistorParams() {
            const preset = document.getElementById('transistorPreset').value;

            if (preset === 'ideal') {
                return { beta: 100, ft: 300e6, vceSat: 0, isIdeal: true };
            }

            if (preset !== 'custom' && BJT_PRESETS[preset]) {
                const p = BJT_PRESETS[preset];
                return { beta: p.beta, ft: p.ft, vceSat: p.vceSat, isIdeal: false };
            }

            // Custom values
            return {
                beta: parseFloat(document.getElementById('beta').value),
                ft: parseFloat(document.getElementById('ft').value) * 1e6,
                vceSat: 0.3,
                isIdeal: false
            };
        }

        function drawSchematic(vals) {
            const sch = new Schematic(400, 380);

            // Transistor at center
            sch.place('npn', 'Q1', 180, 140);

            // Re (emitter resistor)
            sch.place('resistor-v', 'Re', 205, 210, { label: vals.re });

            // Bias resistors
            sch.place('resistor-v', 'R1', 110, 60, { label: vals.r1 });
            sch.place('resistor-v', 'R2', 110, 175, { label: vals.r2 });

            // Cin input cap
            sch.place('capacitor-h', 'Cin', 50, 140, { label: vals.cin });

            // Cout output cap
            sch.place('capacitor-h', 'Cout', 260, 175, { label: vals.cout });

            // Load resistor (dashed - external)
            sch.place('resistor-v', 'Rload', 320, 210, { label: vals.rload, dashed: true });

            // Grounds
            sch.place('ground', 'GND1', 110, 220);
            sch.place('ground', 'GND2', 205, 270);
            sch.place('ground', 'GND3', 320, 255, { dashed: true });

            // --- Wiring ---

            // Vcc rail - collector goes directly to Vcc
            sch.label('Vcc', 205, 25, { anchor: 'middle' });
            sch.wire({ x: 205, y: 30 }, { x: 205, y: 115 }); // Collector to Vcc
            sch.wire({ x: 110, y: 30 }, { x: 205, y: 30 });
            sch.wire({ x: 110, y: 30 }, 'R1.a');

            // Emitter wiring
            sch.wire('Q1.emitter', { x: 205, y: 175 });
            sch.node(205, 175);
            sch.wire({ x: 205, y: 175 }, 'Re.a');
            sch.wire('Re.b', { x: 205, y: 255 });
            sch.wire({ x: 205, y: 255 }, 'GND2.a');

            // Output from emitter
            sch.wire({ x: 205, y: 175 }, { x: 256, y: 175 });
            sch.wire('Cout.b', { x: 290, y: 175 });
            sch.wire({ x: 290, y: 175 }, { x: 320, y: 175 });
            sch.node(320, 175);
            sch.wire({ x: 320, y: 175 }, 'Rload.a', { dashed: true });
            sch.wire('Rload.b', 'GND3.a', { dashed: true });
            sch.label('Out', 330, 179);

            // Bias network
            sch.wire('R1.b', { x: 110, y: 140 });
            sch.node(110, 140);
            sch.wire({ x: 110, y: 140 }, 'R2.a');
            sch.wire('R2.b', 'GND1.a');

            // Base connection
            sch.wire({ x: 110, y: 140 }, 'Cin.b');
            sch.wire('Cin.a', { x: 20, y: 140 });
            sch.label('In', 10, 144);
            sch.wire({ x: 110, y: 140 }, 'Q1.base');

            // Info display
            sch.label('Operating Point:', 20, 300, { bold: true });
            sch.label('Vb = ' + vals.vb, 20, 320);
            sch.label('Ve = ' + vals.ve, 20, 340);
            sch.label('Ie = ' + vals.ie, 20, 360);

            sch.label('Performance:', 150, 300, { bold: true });
            sch.label('Zin = ' + vals.zin, 150, 320);
            sch.label('Zout = ' + vals.zout, 150, 340);
            sch.label('Gain = ' + vals.gain, 150, 360);

            return sch.toSVG();
        }

        // Draw input/output waveforms (no inversion for emitter follower)
        function drawWaveforms(params) {
            const { vinPeak, voutPeak, maxSwing } = params;

            const clipLevel = maxSwing / 2;
            const isClipping = voutPeak > clipLevel;

            const cycles = 2;
            const numPoints = 200;
            const inputPts = [];
            const outputPts = [];

            for (let i = 0; i <= numPoints; i++) {
                const t = (i / numPoints) * cycles;
                const angle = t * 2 * Math.PI;

                const vin = vinPeak * Math.sin(angle);
                let vout = voutPeak * Math.sin(angle); // NO inversion for emitter follower
                if (isClipping) {
                    vout = Math.max(-clipLevel, Math.min(clipLevel, vout));
                }

                inputPts.push({ x: t, y: vin });
                outputPts.push({ x: t, y: vout });
            }

            const displayedVout = isClipping ? clipLevel : voutPeak;
            let outLabel = `Output (${(displayedVout * 1000).toFixed(0)}mV)`;
            if (isClipping) outLabel += ' CLIPPED';

            const graph = new WaveformGraph({ xLabel: '0° phase (output follows input)' });
            graph.addCurve(inputPts, { color: '#88f', label: `Input (${(vinPeak * 1000).toFixed(0)}mV)` });
            graph.addCurve(outputPts, { color: '#3a3', label: outLabel });

            if (isClipping) {
                graph.addHLine(clipLevel, { color: '#c66', label: 'clip' });
                graph.addHLine(-clipLevel, { color: '#c66' });
            }

            return graph.toSVG();
        }

        // Draw DC load line for emitter follower
        function drawLoadLine(params) {
            const { vcc, re, ie, ve, vceSat = 0.3 } = params;

            // For emitter follower: Vce = Vcc - Ve = Vcc - Ie*Re
            // Load line: Ie from 0 to Vcc/Re
            const ieSat = vcc / re; // mA when Ve = Vcc (saturation)
            const vceMax = vcc; // When Ie = 0

            // Current operating point
            const vce = vcc - ve;

            // Swing limits
            const swingDown = ve - vceSat; // Can't go below saturation
            const swingUp = vce - vceSat; // Ve can go up to Vcc - Vce_sat
            const swing = Math.min(swingDown, swingUp);

            const graph = new LoadLineGraph({ yLabel: 'Ie (mA)' });

            // Saturation region
            graph.addRegion(0, vceSat, { color: '#fee', label: 'Sat' });

            // DC Load line (only Re, no Rc)
            graph.addLine(0, ieSat, vceMax, 0, { label: 'DC Load Line' });

            // Q-point
            graph.addQPoint(vce, ie);

            // Swing annotation
            if (swing > 0) {
                graph.addAnnotation(vce, 0.5, `Swing: ${(swing * 2).toFixed(1)}V p-p`);
            }

            return graph.toSVG();
        }

        // Calculate emitter follower frequency response
        function drawFrequencyResponse(params) {
            const { zin, zout, zsource, re, reIntrinsic, rload, cin, cout, beta, fLow, fT } = params;

            // Frequency range: 1Hz to 100MHz
            const fMin = 1;
            const fMax = 100000000;

            // Effective impedances
            const zinEff = zin > 0 ? zin : 1000;
            const rloadEff = rload > 0 ? rload : 1e9;

            // Corner frequencies for high-pass stages (coupling capacitors)
            const fcIn = 1 / (2 * Math.PI * cin * (zsource + zinEff));
            const fcOut = 1 / (2 * Math.PI * cout * (zout + rloadEff));

            // High-frequency limitation: fβ = fT / β
            const fBeta = fT / beta;

            // Miller effect is minimal for emitter follower (gain ≈ 1)
            // Cmiller ≈ Cbc * (1 - Av) ≈ Cbc * 0 ≈ 0 (negligible)
            // So high-frequency limit is dominated by fβ
            const fH = fBeta;

            // Parallel combination of Re and Rload for AC analysis
            const reParallelRload = (re * rload) / (re + rload);

            // Voltage gain (slightly less than 1)
            const gain = reParallelRload / (reIntrinsic + reParallelRload);

            // Input attenuation from source impedance
            const inputAtten = zsource > 0 ? zinEff / (zinEff + zsource) : 1;

            // Magnitude function
            function magnitude(f) {
                // High-pass response from Cin
                const hpIn = f / Math.sqrt(f * f + fcIn * fcIn);
                // High-pass response from Cout
                const hpOut = f / Math.sqrt(f * f + fcOut * fcOut);

                // Low-pass response from transistor HF limitations
                const lpHF = fH / Math.sqrt(f * f + fH * fH);

                const result = inputAtten * gain * hpIn * hpOut * lpHF;
                return Math.max(result, 1e-10);
            }

            // Find mid-band gain for normalization
            const midF = Math.sqrt(fLow * fH);
            const midBandGain = magnitude(Math.min(midF, fH / 10));

            // Create graph
            const graph = new Graph({
                xMin: fMin,
                xMax: fMax,
                yMin: -40,
                yMax: 10
            });

            // Generate response curve (normalized to mid-band = 0dB)
            const normFactor = midBandGain > 0 ? midBandGain : 1;
            const curve = generateResponseCurve(fMin, fMax, f => magnitude(f) / normFactor);
            graph.addCurve(curve, { label: 'Response' });

            // Add reference lines
            graph.addHLine(-3, { color: '#f88', label: '-3 dB' });
            graph.addVLine(fLow, { color: '#88f', label: 'fL' });
            if (isFinite(fH) && fH > 0 && fH < fMax) {
                graph.addVLine(fH, { color: '#8a8', label: 'fβ = ' + fmt(fH, 'Hz') });
            }

            return graph.toSVG();
        }

        function calculate() {
            const vcc = parseFloat(document.getElementById('vcc').value);
            const vin = parseFloat(document.getElementById('vin').value);
            const zsource = parseFloat(document.getElementById('zsource').value);
            const fLow = parseFloat(document.getElementById('fLow').value);
            const rload = parseFloat(document.getElementById('rload').value);
            const ie = parseFloat(document.getElementById('ie').value) / 1000; // mA to A

            // Get transistor parameters from preset or custom
            const transistor = getTransistorParams();
            const beta = transistor.beta;
            const fT = transistor.ft;
            const vceSat = transistor.vceSat;

            // Set Ve at roughly half Vcc for maximum symmetric swing
            const ve = vcc / 2;
            const vb = ve + 0.7;

            // Emitter resistor
            const re = ve / ie;

            // Intrinsic emitter resistance
            const reIntrinsic = V_T / ie;

            // Bias resistors (stiff divider)
            const ib = ie / beta;
            const idivider = ib * 10;
            const rtotal = vcc / idivider;
            const r2 = (vb / vcc) * rtotal;
            const r1 = rtotal - r2;

            // Round to E24
            const r1Rounded = roundToE24(r1);
            const r2Rounded = roundToE24(r2);
            const reRounded = roundToE24(re);

            // Parallel combination of Re and Rload for AC analysis
            const reParallelRload = (reRounded * rload) / (reRounded + rload);

            // Voltage gain (slightly less than 1)
            const gain = reParallelRload / (reIntrinsic + reParallelRload);

            // Input impedance
            const zinBase = beta * (reIntrinsic + reParallelRload);
            const zin = parallel(r1Rounded, r2Rounded, zinBase);

            // Output impedance: (re' + Rsource/beta) || Re
            const zoutBase = reIntrinsic + zsource / beta;
            const zout = parallel(zoutBase, reRounded);

            // Input attenuation from source impedance
            const inputAtten = zin / (zin + zsource);

            // Effective gain
            const effectiveGain = inputAtten * gain;

            // Expected output
            const voutPeak = vin * effectiveGain;

            // Capacitors
            const fcorner = fLow / 10;
            const cinCalc = 1 / (2 * Math.PI * fcorner * zin);
            const coutCalc = 1 / (2 * Math.PI * fcorner * rload);

            const cinRounded = roundCap(cinCalc);
            const coutRounded = roundCap(coutCalc);

            // Swing calculation (use vceSat from transistor params)
            const swingDown = ve - vceSat;
            const swingUp = (vcc - ve) - vceSat;
            const maxSwing = Math.min(swingDown, swingUp) * 2;

            // Warnings
            const warn = document.getElementById('warning');
            let warnings = [];
            let notes = [];

            if (voutPeak * 2 > maxSwing) {
                warnings.push('<b>Clipping warning:</b> Output (' + (voutPeak * 2).toFixed(2) + 'V p-p) exceeds swing (' + maxSwing.toFixed(2) + 'V p-p). Reduce input level.');
            }

            if (zout > rload / 10) {
                notes.push('Output impedance is relatively high compared to load. Consider increasing Ie for lower Zout.');
            }

            if (zsource > zin / 3) {
                warnings.push('<b>High source impedance:</b> Zsource (' + fmtLong(zsource, 'Ω') + ') is too high relative to Zin (' + fmtLong(zin, 'Ω') + '). This causes ' + ((1 - inputAtten) * 100).toFixed(0) + '% signal loss at the input. Either reduce source impedance or use a Darlington configuration for higher Zin.');
            }

            if (warnings.length > 0) {
                warn.innerHTML = warnings.join('<br>');
                warn.classList.remove('hidden');
            } else {
                warn.classList.add('hidden');
            }

            // Display results
            document.getElementById('results').style.display = 'block';

            document.getElementById('schematic').innerHTML = drawSchematic({
                r1: fmt(r1Rounded, 'Ω'),
                r2: fmt(r2Rounded, 'Ω'),
                re: fmt(reRounded, 'Ω'),
                cin: fmt(cinRounded, 'F'),
                cout: fmt(coutRounded, 'F'),
                rload: fmt(rload, 'Ω'),
                vb: fmt(vb, 'V'),
                ve: fmt(ve, 'V'),
                ie: fmt(ie * 1000, 'mA'),
                zin: fmt(zin, 'Ω'),
                zout: fmt(zout, 'Ω'),
                gain: gain.toFixed(3)
            });

            document.getElementById('r1').textContent = fmtLong(r1Rounded, 'Ω');
            document.getElementById('r2').textContent = fmtLong(r2Rounded, 'Ω');
            document.getElementById('re').textContent = fmtLong(reRounded, 'Ω');
            document.getElementById('cin').textContent = fmtLong(cinRounded, 'F');
            document.getElementById('cout').textContent = fmtLong(coutRounded, 'F');

            document.getElementById('zin').textContent = fmtLong(zin, 'Ω');
            document.getElementById('zout').textContent = fmtLong(zout, 'Ω');
            document.getElementById('gain').textContent = gain.toFixed(3) + ' (' + (gain * 100).toFixed(1) + '%)';
            document.getElementById('inputAtten').textContent = (inputAtten * 100).toFixed(1) + '%';
            document.getElementById('effectiveGain').textContent = effectiveGain.toFixed(3) + ' (' + (effectiveGain * 100).toFixed(1) + '%)';
            document.getElementById('expectedOut').textContent = (voutPeak * 1000).toFixed(0) + ' mV peak';

            document.getElementById('note').textContent = notes.join(' ');

            document.getElementById('waveforms').innerHTML = drawWaveforms({
                vinPeak: vin,
                voutPeak: voutPeak,
                maxSwing: maxSwing
            });

            document.getElementById('loadLine').innerHTML = drawLoadLine({
                vcc: vcc,
                re: reRounded / 1000, // kΩ
                ie: ie * 1000, // mA
                ve: ve,
                vceSat: vceSat
            });

            document.getElementById('freqResponse').innerHTML = drawFrequencyResponse({
                zin: zin,
                zout: zout,
                zsource: zsource,
                re: reRounded,
                reIntrinsic: reIntrinsic,
                rload: rload,
                cin: cinRounded,
                cout: coutRounded,
                beta: beta,
                fLow: fLow,
                fT: fT
            });

            // Store values for Falstad export
            storeCalcValues({
                vcc: vcc,
                vb: vb,
                ve: ve,
                vinPeak: vin,
                r1: r1Rounded,
                r2: r2Rounded,
                re: reRounded,
                cin: cinRounded,
                cout: coutRounded,
                rload: rload,
                beta: beta
            });

            // Update step-by-step design calculations
            updateDesignSteps({
                vcc, ve, vb, ie, re, reRounded, reIntrinsic, rload, vin,
                beta, ib, idivider, rtotal, r1, r2, r1Rounded, r2Rounded,
                reParallelRload, gain, zinBase, zin, zsource, zoutBase, zout,
                fLow, fcorner, cinCalc, cinRounded, coutCalc, coutRounded,
                inputAtten, effectiveGain
            });
        }

        function resetDefaults() {
            document.getElementById('vcc').value = '10';
            document.getElementById('vin').value = '1';
            document.getElementById('zsource').value = '1000';
            document.getElementById('fLow').value = '20';
            document.getElementById('rload').value = '600';
            document.getElementById('ie').value = '5';
            document.getElementById('transistorPreset').value = 'ideal';
            updateTransistorFields();
        }

        window.onload = function() {
            updateTransistorFields();
            calculate();
        };
    </script>
</body>
</html>
