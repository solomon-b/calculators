<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emitter Follower Calculator</title>
    <style>
        input[type="number"] {
            width: 80px;
        }
        td[title] {
            cursor: help;
            border-bottom: 1px dotted #999;
        }
        .hint {
            font-size: 0.85em;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>Emitter Follower Calculator</h1>
    <p style="max-width: 600px; color: #555;">
        Design a common-collector (emitter follower) buffer amplifier.
        This topology provides near-unity gain with high input impedance and low output impedance -
        ideal for driving low-impedance loads without loading the source.
    </p>

    <h2>Inputs</h2>
    <table>
        <tr>
            <td title="Supply voltage for the amplifier">Vcc:</td>
            <td><input type="number" id="vcc" value="10" step="0.1" min="1"> V</td>
        </tr>
        <tr>
            <td title="Peak amplitude of your input signal">Input (peak):</td>
            <td><input type="number" id="vin" value="1" step="0.1" min="0.1"> V</td>
        </tr>
        <tr>
            <td title="Output impedance of whatever drives this amplifier. Should be much lower than buffer's Zin.">Source impedance:</td>
            <td><input type="number" id="zsource" value="1000" step="100" min="0"> Ω</td>
        </tr>
        <tr>
            <td title="Lowest frequency you need to pass. Sets the coupling capacitor sizes.">Low frequency (-3dB):</td>
            <td><input type="number" id="fLow" value="20" step="1" min="1"> Hz</td>
        </tr>
        <tr>
            <td title="Resistance of whatever this amplifier drives. The main reason to use an emitter follower!">Load resistance:</td>
            <td><input type="number" id="rload" value="600" step="100" min="10"> Ω</td>
        </tr>
        <tr>
            <td title="DC current through the emitter. Higher values give lower output impedance but use more power.">Emitter current (Ie):</td>
            <td><input type="number" id="ie" value="5" step="1" min="0.5" max="50"> mA</td>
        </tr>
        <tr>
            <td title="Current gain of your transistor. Find this in the datasheet. Typical values: 100-300.">β (hFE):</td>
            <td><input type="number" id="beta" value="100" step="10" min="20"></td>
        </tr>
    </table>
    <p class="hint">Hover over labels for explanations.</p>
    <button onclick="calculate()">Calculate</button>
    <button onclick="resetDefaults()" style="margin-left: 10px;">Reset</button>

    <div id="warning" style="color: red; display: none; margin-top: 10px;"></div>

    <div id="results">
        <h2>Schematic</h2>
        <div id="schematic"></div>

        <h2>Calculated Values</h2>
        <p style="color: #555; font-size: 0.9em; margin-bottom: 10px;">
            Component values rounded to standard E24 series.
        </p>
        <table>
            <tr><td title="Upper bias resistor, sets base voltage together with R2">R1 (upper bias):</td><td id="r1"></td></tr>
            <tr><td title="Lower bias resistor, forms voltage divider with R1">R2 (lower bias):</td><td id="r2"></td></tr>
            <tr><td title="Emitter resistor, sets the bias current and contributes to output impedance">Re (emitter):</td><td id="re"></td></tr>
            <tr><td title="Input coupling capacitor, blocks DC while passing AC signal">Cin (input):</td><td id="cin"></td></tr>
            <tr><td title="Output coupling capacitor, blocks DC bias from reaching the load">Cout (output):</td><td id="cout"></td></tr>
        </table>

        <h2>Buffer Performance</h2>
        <p style="color: #555; font-size: 0.9em; margin-bottom: 10px;">
            The emitter follower excels at impedance transformation - high Zin, low Zout.
            Gain is slightly less than 1 due to the voltage divider formed by re' and Re.
        </p>
        <table>
            <tr><td title="How much resistance the buffer presents to the signal source. Higher is better for not loading the source.">Input impedance (Zin):</td><td id="zin"></td></tr>
            <tr><td title="How much resistance the buffer presents to its load. Lower means it can drive heavier loads.">Output impedance (Zout):</td><td id="zout"></td></tr>
            <tr><td title="Voltage gain, always slightly less than 1">Voltage gain:</td><td id="gain"></td></tr>
            <tr><td title="Signal loss at input due to source impedance">Input attenuation:</td><td id="inputAtten"></td></tr>
            <tr><td title="Overall gain from source to load">Effective gain:</td><td id="effectiveGain"></td></tr>
            <tr><td>Expected output:</td><td id="expectedOut"></td></tr>
        </table>

        <p id="note" style="color: #c60;"></p>

        <h2>Input / Output Waveforms</h2>
        <p style="color: #555; font-size: 0.9em; margin-bottom: 10px;">
            The emitter follower has no phase inversion - output follows input (hence the name).
            Clipping occurs if output exceeds the available swing.
        </p>
        <div id="waveforms"></div>

        <h2>DC Load Line</h2>
        <p style="color: #555; font-size: 0.9em; margin-bottom: 10px;">
            The load line shows the operating path. For an emitter follower, the DC load is just Re
            (collector connects directly to Vcc).
        </p>
        <div id="loadLine"></div>

        <h2>Design Formulas</h2>
        <details>
            <summary style="cursor: pointer; color: #2266cc; font-weight: bold;">Click to show step-by-step design procedure</summary>
            <div style="margin-top: 15px; padding: 15px; background: #f8f8f8; border-radius: 5px; font-size: 0.9em;">
                <h3 style="margin-top: 0;">Step 1: Choose Emitter Current</h3>
                <p>Higher current = lower output impedance, but more power dissipation:</p>
                <code style="display: block; background: #fff; padding: 8px; margin: 5px 0;">
                    I<sub>E</sub> chosen based on load requirements<br>
                    Rule of thumb: I<sub>E</sub> > 10 × (V<sub>out</sub> / R<sub>load</sub>)
                </code>

                <h3>Step 2: Calculate Emitter Resistor</h3>
                <p>Set Ve at roughly half of Vcc for maximum swing:</p>
                <code style="display: block; background: #fff; padding: 8px; margin: 5px 0;">
                    V<sub>E</sub> ≈ V<sub>CC</sub> / 2<br>
                    R<sub>E</sub> = V<sub>E</sub> / I<sub>E</sub>
                </code>

                <h3>Step 3: Calculate Intrinsic Emitter Resistance</h3>
                <code style="display: block; background: #fff; padding: 8px; margin: 5px 0;">
                    r<sub>e</sub>' = 26mV / I<sub>E</sub> = 0.026 / I<sub>E</sub>
                </code>

                <h3>Step 4: Calculate Bias Resistors</h3>
                <code style="display: block; background: #fff; padding: 8px; margin: 5px 0;">
                    V<sub>B</sub> = V<sub>E</sub> + 0.7V<br>
                    I<sub>B</sub> = I<sub>E</sub> / β<br>
                    I<sub>divider</sub> = 10 × I<sub>B</sub><br>
                    R<sub>total</sub> = V<sub>CC</sub> / I<sub>divider</sub><br>
                    R<sub>2</sub> = (V<sub>B</sub> / V<sub>CC</sub>) × R<sub>total</sub><br>
                    R<sub>1</sub> = R<sub>total</sub> - R<sub>2</sub>
                </code>

                <h3>Step 5: Calculate Voltage Gain</h3>
                <p>Gain is slightly less than 1:</p>
                <code style="display: block; background: #fff; padding: 8px; margin: 5px 0;">
                    A<sub>v</sub> = (R<sub>E</sub> ∥ R<sub>load</sub>) / (r<sub>e</sub>' + R<sub>E</sub> ∥ R<sub>load</sub>)<br>
                    A<sub>v</sub> ≈ 0.95 to 0.99 typically
                </code>

                <h3>Step 6: Calculate Input Impedance</h3>
                <code style="display: block; background: #fff; padding: 8px; margin: 5px 0;">
                    Z<sub>in(base)</sub> = β × (r<sub>e</sub>' + R<sub>E</sub> ∥ R<sub>load</sub>)<br>
                    Z<sub>in</sub> = R<sub>1</sub> ∥ R<sub>2</sub> ∥ Z<sub>in(base)</sub>
                </code>

                <h3>Step 7: Calculate Output Impedance</h3>
                <code style="display: block; background: #fff; padding: 8px; margin: 5px 0;">
                    Z<sub>out</sub> = (r<sub>e</sub>' + R<sub>source</sub>/β) ∥ R<sub>E</sub><br>
                    For low R<sub>source</sub>: Z<sub>out</sub> ≈ r<sub>e</sub>' ∥ R<sub>E</sub> ≈ r<sub>e</sub>'
                </code>

                <h3>Step 8: Calculate Coupling Capacitors</h3>
                <code style="display: block; background: #fff; padding: 8px; margin: 5px 0;">
                    C<sub>in</sub> = 1 / (2π × f<sub>low</sub> × Z<sub>in</sub>)<br>
                    C<sub>out</sub> = 1 / (2π × f<sub>low</sub> × R<sub>load</sub>)
                </code>

                <h3>Key Characteristics</h3>
                <ul style="margin-top: 10px;">
                    <li><b>Voltage gain:</b> A<sub>v</sub> ≈ 1 (unity gain buffer)</li>
                    <li><b>Current gain:</b> A<sub>i</sub> ≈ β (high)</li>
                    <li><b>Power gain:</b> A<sub>p</sub> ≈ β (significant)</li>
                    <li><b>Input impedance:</b> High (β × R<sub>E</sub>)</li>
                    <li><b>Output impedance:</b> Low (≈ r<sub>e</sub>')</li>
                    <li><b>Phase shift:</b> 0° (no inversion)</li>
                </ul>
            </div>
        </details>
    </div>

    <script src="../common.js"></script>
    <script src="../schematic.js"></script>
    <script>
        function drawSchematic(vals) {
            const sch = new Schematic(400, 380);

            // Transistor at center
            sch.place('npn', 'Q1', 180, 140);

            // Re (emitter resistor)
            sch.place('resistor-v', 'Re', 205, 210, { label: vals.re });

            // Bias resistors
            sch.place('resistor-v', 'R1', 110, 60, { label: vals.r1 });
            sch.place('resistor-v', 'R2', 110, 175, { label: vals.r2 });

            // Cin input cap
            sch.place('capacitor-h', 'Cin', 50, 140, { label: vals.cin });

            // Cout output cap
            sch.place('capacitor-h', 'Cout', 260, 175, { label: vals.cout });

            // Load resistor (dashed - external)
            sch.place('resistor-v', 'Rload', 320, 210, { label: vals.rload, dashed: true });

            // Grounds
            sch.place('ground', 'GND1', 110, 220);
            sch.place('ground', 'GND2', 205, 270);
            sch.place('ground', 'GND3', 320, 255, { dashed: true });

            // --- Wiring ---

            // Vcc rail - collector goes directly to Vcc
            sch.label('Vcc', 205, 25, { anchor: 'middle' });
            sch.wire({ x: 205, y: 30 }, { x: 205, y: 115 }); // Collector to Vcc
            sch.wire({ x: 110, y: 30 }, { x: 205, y: 30 });
            sch.wire({ x: 110, y: 30 }, 'R1.a');

            // Emitter wiring
            sch.wire('Q1.emitter', { x: 205, y: 175 });
            sch.node(205, 175);
            sch.wire({ x: 205, y: 175 }, 'Re.a');
            sch.wire('Re.b', { x: 205, y: 255 });
            sch.wire({ x: 205, y: 255 }, 'GND2.a');

            // Output from emitter
            sch.wire({ x: 205, y: 175 }, { x: 256, y: 175 });
            sch.wire('Cout.b', { x: 290, y: 175 });
            sch.wire({ x: 290, y: 175 }, { x: 320, y: 175 });
            sch.node(320, 175);
            sch.wire({ x: 320, y: 175 }, 'Rload.a', { dashed: true });
            sch.wire('Rload.b', 'GND3.a', { dashed: true });
            sch.label('Out', 330, 179);

            // Bias network
            sch.wire('R1.b', { x: 110, y: 140 });
            sch.node(110, 140);
            sch.wire({ x: 110, y: 140 }, 'R2.a');
            sch.wire('R2.b', 'GND1.a');

            // Base connection
            sch.wire({ x: 110, y: 140 }, 'Cin.b');
            sch.wire('Cin.a', { x: 20, y: 140 });
            sch.label('In', 10, 144);
            sch.wire({ x: 110, y: 140 }, 'Q1.base');

            // Info display
            sch.label('Operating Point:', 20, 300, { bold: true });
            sch.label('Vb = ' + vals.vb, 20, 320);
            sch.label('Ve = ' + vals.ve, 20, 340);
            sch.label('Ie = ' + vals.ie, 20, 360);

            sch.label('Performance:', 150, 300, { bold: true });
            sch.label('Zin = ' + vals.zin, 150, 320);
            sch.label('Zout = ' + vals.zout, 150, 340);
            sch.label('Gain = ' + vals.gain, 150, 360);

            return sch.toSVG();
        }

        // Draw input/output waveforms (no inversion for emitter follower)
        function drawWaveforms(params) {
            const { vinPeak, voutPeak, maxSwing } = params;

            const width = 500;
            const height = 200;
            const margin = { top: 30, right: 20, bottom: 30, left: 50 };
            const plotW = width - margin.left - margin.right;
            const plotH = height - margin.top - margin.bottom;

            const clipLevel = maxSwing / 2;
            const isClipping = voutPeak > clipLevel;

            const maxV = Math.max(vinPeak, isClipping ? clipLevel : voutPeak) * 1.05;
            const cycles = 2;
            const numPoints = 200;

            const xScale = (t) => margin.left + (t / cycles) * plotW;
            const yScale = (v) => margin.top + plotH / 2 - (v / maxV) * (plotH / 2);

            let svg = `<svg width="${width}" height="${height}" style="font-family: monospace; font-size: 11px;">`;

            svg += `<rect x="${margin.left}" y="${margin.top}" width="${plotW}" height="${plotH}" fill="#fafafa" stroke="#ccc"/>`;
            svg += `<line x1="${margin.left}" y1="${yScale(0)}" x2="${margin.left + plotW}" y2="${yScale(0)}" stroke="#ccc" stroke-width="1"/>`;

            if (isClipping) {
                svg += `<line x1="${margin.left}" y1="${yScale(clipLevel)}" x2="${margin.left + plotW}" y2="${yScale(clipLevel)}" stroke="#c66" stroke-dasharray="4,2"/>`;
                svg += `<line x1="${margin.left}" y1="${yScale(-clipLevel)}" x2="${margin.left + plotW}" y2="${yScale(-clipLevel)}" stroke="#c66" stroke-dasharray="4,2"/>`;
                svg += `<text x="${margin.left + plotW + 5}" y="${yScale(clipLevel) + 4}" fill="#c66" font-size="9">clip</text>`;
                svg += `<text x="${margin.left + plotW + 5}" y="${yScale(-clipLevel) + 4}" fill="#c66" font-size="9">clip</text>`;
            }

            let inputPath = '';
            let outputPath = '';

            for (let i = 0; i <= numPoints; i++) {
                const t = (i / numPoints) * cycles;
                const angle = t * 2 * Math.PI;

                const vin = vinPeak * Math.sin(angle);
                let vout = voutPeak * Math.sin(angle); // NO inversion for emitter follower
                if (isClipping) {
                    vout = Math.max(-clipLevel, Math.min(clipLevel, vout));
                }

                const x = xScale(t);
                const yIn = yScale(vin);
                const yOut = yScale(vout);

                if (i === 0) {
                    inputPath = `M ${x} ${yIn}`;
                    outputPath = `M ${x} ${yOut}`;
                } else {
                    inputPath += ` L ${x} ${yIn}`;
                    outputPath += ` L ${x} ${yOut}`;
                }
            }

            svg += `<path d="${inputPath}" fill="none" stroke="#88f" stroke-width="2"/>`;
            svg += `<path d="${outputPath}" fill="none" stroke="#3a3" stroke-width="2"/>`;

            svg += `<text x="${margin.left - 5}" y="${yScale(maxV * 0.8) + 4}" text-anchor="end" font-size="10">+</text>`;
            svg += `<text x="${margin.left - 5}" y="${yScale(-maxV * 0.8) + 4}" text-anchor="end" font-size="10">−</text>`;
            svg += `<text x="${margin.left - 5}" y="${yScale(0) + 4}" text-anchor="end" font-size="10">0</text>`;

            svg += `<line x1="${margin.left + 10}" y1="${margin.top - 15}" x2="${margin.left + 30}" y2="${margin.top - 15}" stroke="#88f" stroke-width="2"/>`;
            svg += `<text x="${margin.left + 35}" y="${margin.top - 11}" font-size="10">Input (${(vinPeak * 1000).toFixed(0)}mV peak)</text>`;

            svg += `<line x1="${margin.left + 180}" y1="${margin.top - 15}" x2="${margin.left + 200}" y2="${margin.top - 15}" stroke="#3a3" stroke-width="2"/>`;
            svg += `<text x="${margin.left + 205}" y="${margin.top - 11}" font-size="10">Output (${(Math.min(voutPeak, clipLevel) * 1000).toFixed(0)}mV peak${isClipping ? ', clipped' : ''})</text>`;

            svg += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle" fill="#666" font-size="10">0° phase (output follows input)</text>`;

            svg += '</svg>';
            return svg;
        }

        // Draw DC load line for emitter follower
        function drawLoadLine(params) {
            const { vcc, re, ie, ve } = params;

            const width = 450;
            const height = 280;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const plotW = width - margin.left - margin.right;
            const plotH = height - margin.top - margin.bottom;

            // For emitter follower: Vce = Vcc - Ve = Vcc - Ie*Re
            // Load line: Ie from 0 to Vcc/Re
            const ieSat = vcc / re; // mA when Ve = Vcc (saturation)
            const vceMax = vcc; // When Ie = 0

            // Current operating point
            const vce = vcc - ve;

            const axisVceMax = vceMax * 1.1;
            const axisIeMax = ieSat * 1.1;

            const xScale = (v) => margin.left + (v / axisVceMax) * plotW;
            const yScale = (i) => margin.top + plotH - (i / axisIeMax) * plotH;

            let svg = `<svg width="${width}" height="${height}" style="font-family: monospace; font-size: 11px;">`;

            svg += `<rect x="${margin.left}" y="${margin.top}" width="${plotW}" height="${plotH}" fill="#fafafa" stroke="#ccc"/>`;

            // Grid
            const vceStep = Math.ceil(axisVceMax / 5);
            for (let v = 0; v <= axisVceMax; v += vceStep) {
                const x = xScale(v);
                svg += `<line x1="${x}" y1="${margin.top}" x2="${x}" y2="${margin.top + plotH}" stroke="#ddd"/>`;
                svg += `<text x="${x}" y="${height - 25}" text-anchor="middle">${v.toFixed(0)}</text>`;
            }
            const ieStep = Math.ceil(axisIeMax * 10) / 50;
            for (let i = 0; i <= axisIeMax; i += ieStep) {
                const y = yScale(i);
                svg += `<line x1="${margin.left}" y1="${y}" x2="${margin.left + plotW}" y2="${y}" stroke="#ddd"/>`;
                svg += `<text x="${margin.left - 5}" y="${y + 4}" text-anchor="end">${i.toFixed(1)}</text>`;
            }

            svg += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle">Vce (V)</text>`;
            svg += `<text x="15" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 15, ${height / 2})">Ie (mA)</text>`;

            // Saturation region
            const vcesat = 0.3;
            svg += `<rect x="${margin.left}" y="${margin.top}" width="${xScale(vcesat) - margin.left}" height="${plotH}" fill="#fee" opacity="0.5"/>`;
            svg += `<text x="${xScale(vcesat/2)}" y="${margin.top + 15}" text-anchor="middle" fill="#c66" font-size="9">Sat</text>`;

            // DC Load line (only Re, no Rc)
            svg += `<line x1="${xScale(0)}" y1="${yScale(ieSat)}" x2="${xScale(vceMax)}" y2="${yScale(0)}" stroke="#2266cc" stroke-width="2"/>`;
            svg += `<text x="${xScale(vceMax * 0.6)}" y="${yScale(ieSat * 0.4) - 5}" fill="#2266cc" font-size="10">DC Load Line</text>`;

            // Q-point
            const qX = xScale(vce);
            const qY = yScale(ie);
            svg += `<circle cx="${qX}" cy="${qY}" r="6" fill="#c33" stroke="#fff" stroke-width="2"/>`;
            svg += `<text x="${qX + 10}" y="${qY - 10}" fill="#c33" font-weight="bold">Q-point</text>`;
            svg += `<text x="${qX + 10}" y="${qY + 5}" fill="#c33" font-size="10">(${vce.toFixed(1)}V, ${ie.toFixed(1)}mA)</text>`;

            // Swing limits
            const swingDown = ve - 0.3; // Can't go below saturation
            const swingUp = vce - 0.3; // Ve can go up to Vcc - Vce_sat
            const swing = Math.min(swingDown, swingUp);

            if (swing > 0) {
                svg += `<text x="${qX}" y="${margin.top + plotH - 10}" text-anchor="middle" fill="#3a3" font-size="10">Swing: ${(swing * 2).toFixed(1)}V p-p</text>`;
            }

            svg += '</svg>';
            return svg;
        }

        function calculate() {
            const vcc = parseFloat(document.getElementById('vcc').value);
            const vin = parseFloat(document.getElementById('vin').value);
            const zsource = parseFloat(document.getElementById('zsource').value);
            const fLow = parseFloat(document.getElementById('fLow').value);
            const rload = parseFloat(document.getElementById('rload').value);
            const ie = parseFloat(document.getElementById('ie').value) / 1000; // mA to A
            const beta = parseFloat(document.getElementById('beta').value);

            // Set Ve at roughly half Vcc for maximum symmetric swing
            const ve = vcc / 2;
            const vb = ve + 0.7;

            // Emitter resistor
            const re = ve / ie;

            // Intrinsic emitter resistance
            const reIntrinsic = 0.026 / ie;

            // Bias resistors (stiff divider)
            const ib = ie / beta;
            const idivider = ib * 10;
            const rtotal = vcc / idivider;
            const r2 = (vb / vcc) * rtotal;
            const r1 = rtotal - r2;

            // Round to E24
            const r1Rounded = roundToE24(r1);
            const r2Rounded = roundToE24(r2);
            const reRounded = roundToE24(re);

            // Parallel combination of Re and Rload for AC analysis
            const reParallelRload = (reRounded * rload) / (reRounded + rload);

            // Voltage gain (slightly less than 1)
            const gain = reParallelRload / (reIntrinsic + reParallelRload);

            // Input impedance
            const zinBase = beta * (reIntrinsic + reParallelRload);
            const zin = parallel(r1Rounded, r2Rounded, zinBase);

            // Output impedance: (re' + Rsource/beta) || Re
            const zoutBase = reIntrinsic + zsource / beta;
            const zout = parallel(zoutBase, reRounded);

            // Input attenuation from source impedance
            const inputAtten = zin / (zin + zsource);

            // Effective gain
            const effectiveGain = inputAtten * gain;

            // Expected output
            const voutPeak = vin * effectiveGain;

            // Capacitors
            const fcorner = fLow / 10;
            const cinCalc = 1 / (2 * Math.PI * fcorner * zin);
            const coutCalc = 1 / (2 * Math.PI * fcorner * rload);

            const cinRounded = roundCap(cinCalc);
            const coutRounded = roundCap(coutCalc);

            // Swing calculation
            const swingDown = ve - 0.3;
            const swingUp = (vcc - ve) - 0.3;
            const maxSwing = Math.min(swingDown, swingUp) * 2;

            // Warnings
            const warn = document.getElementById('warning');
            let warnings = [];
            let notes = [];

            if (voutPeak * 2 > maxSwing) {
                warnings.push('<b>Clipping warning:</b> Output (' + (voutPeak * 2).toFixed(2) + 'V p-p) exceeds swing (' + maxSwing.toFixed(2) + 'V p-p). Reduce input level.');
            }

            if (zout > rload / 10) {
                notes.push('Output impedance is relatively high compared to load. Consider increasing Ie for lower Zout.');
            }

            if (zsource > zin / 3) {
                warnings.push('<b>High source impedance:</b> Zsource (' + fmtLong(zsource, 'Ω') + ') is too high relative to Zin (' + fmtLong(zin, 'Ω') + '). This causes ' + ((1 - inputAtten) * 100).toFixed(0) + '% signal loss at the input. Either reduce source impedance or use a Darlington configuration for higher Zin.');
            }

            if (warnings.length > 0) {
                warn.innerHTML = warnings.join('<br>');
                warn.style.display = 'block';
            } else {
                warn.style.display = 'none';
            }

            // Display results
            document.getElementById('results').style.display = 'block';

            document.getElementById('schematic').innerHTML = drawSchematic({
                r1: fmt(r1Rounded, 'Ω'),
                r2: fmt(r2Rounded, 'Ω'),
                re: fmt(reRounded, 'Ω'),
                cin: fmt(cinRounded, 'F'),
                cout: fmt(coutRounded, 'F'),
                rload: fmt(rload, 'Ω'),
                vb: fmt(vb, 'V'),
                ve: fmt(ve, 'V'),
                ie: fmt(ie * 1000, 'mA'),
                zin: fmt(zin, 'Ω'),
                zout: fmt(zout, 'Ω'),
                gain: gain.toFixed(3)
            });

            document.getElementById('r1').textContent = fmtLong(r1Rounded, 'Ω');
            document.getElementById('r2').textContent = fmtLong(r2Rounded, 'Ω');
            document.getElementById('re').textContent = fmtLong(reRounded, 'Ω');
            document.getElementById('cin').textContent = fmtLong(cinRounded, 'F');
            document.getElementById('cout').textContent = fmtLong(coutRounded, 'F');

            document.getElementById('zin').textContent = fmtLong(zin, 'Ω');
            document.getElementById('zout').textContent = fmtLong(zout, 'Ω');
            document.getElementById('gain').textContent = gain.toFixed(3) + ' (' + (gain * 100).toFixed(1) + '%)';
            document.getElementById('inputAtten').textContent = (inputAtten * 100).toFixed(1) + '%';
            document.getElementById('effectiveGain').textContent = effectiveGain.toFixed(3) + ' (' + (effectiveGain * 100).toFixed(1) + '%)';
            document.getElementById('expectedOut').textContent = (voutPeak * 1000).toFixed(0) + ' mV peak';

            document.getElementById('note').textContent = notes.join(' ');

            document.getElementById('waveforms').innerHTML = drawWaveforms({
                vinPeak: vin,
                voutPeak: voutPeak,
                maxSwing: maxSwing
            });

            document.getElementById('loadLine').innerHTML = drawLoadLine({
                vcc: vcc,
                re: reRounded / 1000, // kΩ
                ie: ie * 1000, // mA
                ve: ve
            });
        }

        function resetDefaults() {
            document.getElementById('vcc').value = '10';
            document.getElementById('vin').value = '1';
            document.getElementById('zsource').value = '1000';
            document.getElementById('fLow').value = '20';
            document.getElementById('rload').value = '600';
            document.getElementById('ie').value = '5';
            document.getElementById('beta').value = '100';
            calculate();
        }

        window.onload = calculate;
    </script>
</body>
</html>
