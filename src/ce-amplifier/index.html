<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CE Amplifier Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
    tailwind.config = {
        theme: {
            extend: {
                colors: {
                    primary: '#2266cc',
                }
            }
        }
    }
    </script>
    <style>
        /* Styles for dynamically generated SVG */
        svg text { font-family: ui-monospace, monospace; }
    </style>
</head>
<body class="max-w-3xl mx-auto px-4 sm:px-6 py-8 font-sans leading-relaxed">
    <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-4">CE Amplifier Calculator</h1>
    <p class="text-gray-600 text-lg max-w-xl mb-6">
        Design a common-emitter amplifier with voltage divider biasing.
        This topology trades some gain for stable, predictable operation across transistor variations.
    </p>

    <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Inputs</h2>
    <div class="overflow-x-auto">
        <table class="w-full sm:w-auto">
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Supply voltage for the amplifier">Vcc:</td>
                <td class="py-2"><input type="number" id="vcc" value="10" step="0.1" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> V</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Voltage gain of the transistor stage (Vout/Vin)">Desired gain (Av):</td>
                <td class="py-2"><input type="number" id="gain" value="5" step="1" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> V/V</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Peak amplitude of your input signal (used to check for clipping)">Input (peak):</td>
                <td class="py-2"><input type="number" id="vin" value="100" step="10" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> mV</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Output impedance of whatever drives this amplifier. Higher values reduce effective gain.">Source impedance:</td>
                <td class="py-2"><input type="number" id="zsource" value="0" step="100" min="0" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> &#8486;</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Lowest frequency you need to amplify. Sets the coupling capacitor sizes.">Low frequency (-3dB):</td>
                <td class="py-2"><input type="number" id="fLow" value="20" step="1" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> Hz</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Resistance of whatever this amplifier drives. Lower values reduce effective gain. Leave empty for open circuit.">Load (optional):</td>
                <td class="py-2"><input type="number" id="rload" value="" placeholder="&#8734;" step="1000" min="100" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> &#8486;</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Bypassing Re with a capacitor increases AC gain but makes it less predictable and more dependent on transistor parameters.">Bypass Re:</td>
                <td class="py-2">
                    <select id="bypassMode" class="px-2 py-1 border border-gray-300 rounded text-sm">
                        <option value="none">No bypass (stable gain)</option>
                        <option value="full">Full bypass (max gain)</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="DC current through the collector. Higher values give more bandwidth but use more power.">Collector current (Ic):</td>
                <td class="py-2"><input type="number" id="ic" value="1" step="0.5" min="0.1" max="20" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> mA</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Current gain of your transistor. Find this in the datasheet. Typical values: 100-300.">&#946; (hFE):</td>
                <td class="py-2"><input type="number" id="beta" value="100" step="10" min="20" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"></td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Transition frequency - where the transistor's current gain drops to 1. Limits high-frequency response.">fT (transistor):</td>
                <td class="py-2"><input type="number" id="ft" value="150" step="50" min="10" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> MHz</td>
            </tr>
        </table>
    </div>
    <p class="text-sm text-gray-400 mt-2">Hover over labels for explanations.</p>
    <div class="flex flex-wrap gap-2 mt-4">
        <button onclick="calculate()" class="px-5 py-2 bg-primary text-white rounded hover:bg-blue-700 cursor-pointer text-sm">Calculate</button>
        <button onclick="resetDefaults()" class="px-5 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 cursor-pointer text-sm">Reset</button>
    </div>

    <div id="warning" class="hidden text-red-700 bg-red-50 border-l-4 border-red-600 p-4 my-4"></div>

    <div id="results">
        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Schematic</h2>
        <div id="schematic" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Calculated Values</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            Component values rounded to standard E24 series. The bias resistors (R1, R2) set the DC operating point.
        </p>
        <div class="overflow-x-auto">
            <table class="w-full sm:w-auto">
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Upper bias resistor, sets base voltage together with R2">R1 (upper bias):</td><td id="r1" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Lower bias resistor, forms voltage divider with R1">R2 (lower bias):</td><td id="r2" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Collector resistor, converts collector current changes to voltage changes">Rc (collector):</td><td id="rc" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Emitter resistor, provides negative feedback for stability. Gain &#8776; Rc/Re">Re (emitter):</td><td id="re" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Input coupling capacitor, blocks DC while passing AC signal">Cin (input):</td><td id="cin" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Output coupling capacitor, blocks DC bias from reaching the load">Cout (output):</td><td id="cout" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Emitter bypass capacitor, shorts Re at AC frequencies to increase gain">Ce (bypass):</td><td id="ce" class="py-2 text-right font-mono"></td></tr>
            </table>
        </div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Gain Analysis</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The gain you actually get depends on source and load impedances. The transistor provides its gain,
            but some signal is lost at the input (voltage divider with source impedance) and output (voltage divider with load).
        </p>
        <div class="overflow-x-auto">
            <table class="w-full sm:w-auto">
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="How much resistance the amplifier presents to the signal source. Higher is generally better.">Input impedance (Zin):</td><td id="zin" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="How much resistance the amplifier presents to its load. Lower means it can drive heavier loads.">Output impedance (Zout):</td><td id="zout" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="The gain of the transistor stage itself: Rc / (Re + re')">Transistor gain (Av):</td><td id="transGain" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Signal loss at input due to source impedance. Zin / (Zin + Zsource)">Input attenuation:</td><td id="inputAtten" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Signal loss at output due to load. Rload / (Rload + Zout)">Output attenuation:</td><td id="outputAtten" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400 font-bold" title="What you actually measure: transistor gain &#215; input attenuation &#215; output attenuation">Effective gain:</td><td id="effectiveGain" class="py-2 text-right font-mono font-bold"></td></tr>
                <tr><td class="py-2 pr-4">Expected output:</td><td id="expectedOut" class="py-2 text-right font-mono"></td></tr>
            </table>
        </div>

        <p id="note" class="text-amber-600 mt-4"></p>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Input / Output Waveforms</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The CE amplifier inverts the signal (180&#176; phase shift) and amplifies it.
            If the output exceeds the available swing, it clips (flattens) at the peaks.
        </p>
        <div id="waveforms" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Load Lines</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The DC load line (solid) shows the operating path set by Rc + Re.
            When a load is connected, the AC load line (dashed) is steeper because AC sees Rc || Rload.
            The Q-point sits on both lines - DC sets the bias, AC determines the signal swing.
        </p>
        <div id="loadLine" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Frequency Response</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            Low frequencies are limited by coupling capacitors (Cin, Cout) and bypass capacitor (Ce).
            High frequencies are limited by the transistor's internal capacitances and &#946; rolloff.
        </p>
        <div id="freqResponse" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Design Formulas</h2>
        <details class="my-4">
            <summary class="cursor-pointer text-primary font-bold">Click to show step-by-step design procedure</summary>
            <div class="mt-4 p-4 bg-gray-100 rounded text-sm">
                <h3 class="text-base font-semibold text-gray-600 mt-0 mb-2">Step 1: Set the DC Operating Point</h3>
                <p>Choose emitter voltage for thermal stability (typically 10% of Vcc or 1V minimum):</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    V<sub>E</sub> = max(0.1 &#215; V<sub>CC</sub>, 1V)<br>
                    V<sub>B</sub> = V<sub>E</sub> + 0.7V
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 2: Calculate Emitter Resistor</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    R<sub>E</sub> = V<sub>E</sub> / I<sub>C</sub>
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 3: Calculate Intrinsic Emitter Resistance</h3>
                <p>This is the transistor's internal resistance, temperature dependent:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    r<sub>e</sub>' = 26mV / I<sub>C</sub> = 0.026 / I<sub>C</sub>
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 4: Calculate Collector Resistor for Desired Gain</h3>
                <p><b>Without bypass (stable gain):</b></p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    A<sub>v</sub> = R<sub>C</sub> / (R<sub>E</sub> + r<sub>e</sub>')<br>
                    &#8756; R<sub>C</sub> = A<sub>v</sub> &#215; (R<sub>E</sub> + r<sub>e</sub>')
                </code>
                <p><b>With full bypass (maximum gain):</b></p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    A<sub>v</sub> = R<sub>C</sub> / r<sub>e</sub>'<br>
                    &#8756; R<sub>C</sub> = A<sub>v</sub> &#215; r<sub>e</sub>'
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 5: Verify Operating Point</h3>
                <p>Check that V<sub>C</sub> leaves room for the transistor to operate:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    V<sub>C</sub> = V<sub>CC</sub> - I<sub>C</sub> &#215; R<sub>C</sub><br>
                    Requirement: V<sub>C</sub> > V<sub>E</sub> + 0.3V (active region)
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 6: Calculate Bias Resistors</h3>
                <p>Use the "stiff divider" rule - divider current should be ~10&#215; base current:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    I<sub>B</sub> = I<sub>C</sub> / &#946;<br>
                    I<sub>divider</sub> = 10 &#215; I<sub>B</sub><br>
                    R<sub>total</sub> = V<sub>CC</sub> / I<sub>divider</sub><br>
                    R<sub>2</sub> = (V<sub>B</sub> / V<sub>CC</sub>) &#215; R<sub>total</sub><br>
                    R<sub>1</sub> = R<sub>total</sub> - R<sub>2</sub>
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 7: Calculate Input Impedance</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    Z<sub>in(base)</sub> = &#946; &#215; (R<sub>E</sub> + r<sub>e</sub>') &nbsp;&nbsp;<i>[without bypass]</i><br>
                    Z<sub>in(base)</sub> = &#946; &#215; r<sub>e</sub>' &nbsp;&nbsp;<i>[with bypass]</i><br>
                    Z<sub>in</sub> = R<sub>1</sub> &#8741; R<sub>2</sub> &#8741; Z<sub>in(base)</sub>
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 8: Calculate Coupling Capacitors</h3>
                <p>Size for -3dB at the desired low frequency cutoff:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    C<sub>in</sub> = 1 / (2&#960; &#215; f<sub>low</sub> &#215; Z<sub>in</sub>)<br>
                    C<sub>out</sub> = 1 / (2&#960; &#215; f<sub>low</sub> &#215; R<sub>load</sub>)
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 9: Calculate Bypass Capacitor (if used)</h3>
                <p>Must have low impedance at lowest frequency of interest:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    X<sub>Ce</sub> << R<sub>E</sub> at f<sub>low</sub><br>
                    C<sub>E</sub> &#8776; 10 / (2&#960; &#215; f<sub>low</sub> &#215; R<sub>E</sub>)
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 10: Calculate Effective Gain</h3>
                <p>Account for loading at input and output:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    Input attenuation = Z<sub>in</sub> / (Z<sub>in</sub> + Z<sub>source</sub>)<br>
                    Output attenuation = R<sub>load</sub> / (R<sub>load</sub> + R<sub>C</sub>)<br>
                    Effective gain = A<sub>v</sub> &#215; input atten &#215; output atten
                </code>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Key Relationships</h3>
                <ul class="list-disc ml-5 space-y-1">
                    <li><b>Output impedance:</b> Z<sub>out</sub> &#8776; R<sub>C</sub></li>
                    <li><b>Voltage swing:</b> Limited by V<sub>C</sub> &#8722; V<sub>E</sub> (down) and V<sub>CC</sub> &#8722; V<sub>C</sub> (up)</li>
                    <li><b>AC load line slope:</b> &#8722;1/(R<sub>C</sub> &#8741; R<sub>load</sub>)</li>
                    <li><b>DC load line slope:</b> &#8722;1/(R<sub>C</sub> + R<sub>E</sub>)</li>
                </ul>
            </div>
        </details>
    </div>

    <script src="../common.js"></script>
    <script src="../schematic.js"></script>
    <script src="../graph.js"></script>
    <script>
        function drawSchematic(vals) {
            const sch = new Schematic(450, 420);
            const hasBypass = vals.ce !== null;
            const hasLoad = vals.rload !== null;

            // Transistor at center
            sch.place('npn', 'Q1', 200, 160);

            // Rc (collector resistor)
            sch.place('resistor-v', 'Rc', 225, 75, { label: vals.rc });

            // Re (single emitter resistor) - label on left if bypass cap present
            sch.place('resistor-v', 'Re', 225, 230, { label: vals.re, labelPos: hasBypass ? 'left' : 'right' });

            // Ce bypass cap (only if bypass mode)
            if (hasBypass) {
                sch.place('capacitor-v', 'Ce', 280, 230, { label: vals.ce });
            }

            // Bias resistors
            sch.place('resistor-v', 'R1', 130, 80, { label: vals.r1 });
            sch.place('resistor-v', 'R2', 130, 195, { label: vals.r2 });

            // Cin input cap
            sch.place('capacitor-h', 'Cin', 70, 160, { label: vals.cin });

            // Cout output cap
            sch.place('capacitor-h', 'Cout', 290, 110, { label: vals.cout });

            // Load resistor (dashed - external, only if specified)
            if (hasLoad) {
                sch.place('resistor-v', 'Rload', 350, 165, { label: vals.rload, dashed: true });
                sch.place('ground', 'GND3', 350, 210, { dashed: true });
            }

            // Grounds
            sch.place('ground', 'GND1', 130, 240);
            sch.place('ground', 'GND2', 225, 290);

            // --- Wiring ---

            // Vcc rail
            sch.label('Vcc', 225, 25, { anchor: 'middle' });
            sch.wire({ x: 225, y: 30 }, 'Rc.a');
            sch.wire({ x: 130, y: 30 }, { x: 225, y: 30 });
            sch.wire({ x: 130, y: 30 }, 'R1.a');

            // Rc to collector
            sch.wire('Rc.b', { x: 225, y: 110 });
            sch.node(225, 110);

            // Collector to output cap
            sch.wire({ x: 225, y: 110 }, { x: 225, y: 135 });
            sch.wire({ x: 225, y: 110 }, { x: 286, y: 110 });
            sch.wire('Cout.b', { x: 320, y: 110 });

            if (hasLoad) {
                sch.wire({ x: 320, y: 110 }, { x: 350, y: 110 });
                sch.node(350, 110);
                sch.wire({ x: 350, y: 110 }, 'Rload.a', { dashed: true });
                sch.wire('Rload.b', 'GND3.a', { dashed: true });
            }
            sch.label('Out', hasLoad ? 360 : 330, 114);

            // Emitter wiring
            sch.wire('Q1.emitter', { x: 225, y: 195 });
            sch.wire({ x: 225, y: 195 }, 'Re.a');
            sch.wire('Re.b', { x: 225, y: 275 });
            sch.node(225, 275);
            sch.wire({ x: 225, y: 275 }, 'GND2.a');

            // Ce bypass parallel to Re (if present)
            if (hasBypass) {
                sch.wire({ x: 225, y: 195 }, { x: 280, y: 195 });
                sch.wire({ x: 280, y: 195 }, 'Ce.a');
                sch.wire('Ce.b', { x: 280, y: 275 });
                sch.wire({ x: 280, y: 275 }, { x: 225, y: 275 });
            }

            // Bias network
            sch.wire('R1.b', { x: 130, y: 160 });
            sch.node(130, 160);
            sch.wire({ x: 130, y: 160 }, 'R2.a');
            sch.wire('R2.b', 'GND1.a');

            // Base connection
            sch.wire({ x: 130, y: 160 }, 'Cin.b');
            sch.wire('Cin.a', { x: 40, y: 160 });
            sch.label('In', 25, 164);
            sch.wire({ x: 130, y: 160 }, 'Q1.base');

            // Info display
            sch.label('Operating Point:', 20, 330, { bold: true });
            sch.label('Vb = ' + vals.vb, 20, 350);
            sch.label('Ve = ' + vals.ve, 20, 370);
            sch.label('Vc = ' + vals.vc, 20, 390);
            sch.label('Ic = ' + vals.ic, 130, 350);
            sch.label('Swing = ' + vals.swing, 130, 370);

            sch.label('Gain:', 260, 330, { bold: true });
            sch.label('Transistor: ' + vals.transGain, 260, 350);
            sch.label('Effective: ' + vals.effectiveGain, 260, 370);

            return sch.toSVG();
        }

        // Calculate CE amplifier frequency response
        function drawFrequencyResponse(params) {
            const { zin, zsource, rc, re, reEffective, reIntrinsic, rload, cin, cout, ce, beta, fLow, fT, bypassMode } = params;

            // Frequency range: 1Hz to 100MHz
            const fMin = 1;
            const fMax = 100000000;

            // Handle infinite load and ensure positive values
            const rloadEff = (isFinite(rload) && rload > 0) ? rload : 1e9;
            const zinEff = zin > 0 ? zin : 1000;

            // Corner frequencies for each high-pass stage
            const fcIn = 1 / (2 * Math.PI * cin * (zsource + zinEff));
            const fcOut = 1 / (2 * Math.PI * cout * (rc + rloadEff));
            const fcBypass = (bypassMode === 'full' && ce > 0 && re > 0) ? 1 / (2 * Math.PI * ce * re) : 0;

            // High-frequency limitations
            // fβ is where β starts rolling off
            const fBeta = fT / beta;

            // Effective load for gain calculation
            const rcParallel = parallel(rc, rloadEff);

            // Miller effect: Cbc (typ ~2pF) multiplied by voltage gain
            // Creates dominant high-frequency pole
            const Cbc = 2e-12; // Typical collector-base capacitance
            const Av = rcParallel / (reEffective + reIntrinsic); // Voltage gain
            const Cmiller = Cbc * (1 + Av);

            // High-frequency pole from Miller + source impedance
            const rSource = zsource > 0 ? parallel(zsource, zinEff) : zinEff;
            const fHmiller = 1 / (2 * Math.PI * rSource * Cmiller);

            // Combined high-frequency pole (use dominant one)
            const fH = Math.min(fBeta, fHmiller);

            // Input and output attenuation (constant with frequency)
            const inputAtten = zsource > 0 ? zinEff / (zinEff + zsource) : 1;
            const outputAtten = isFinite(rload) ? rload / (rload + rc) : 1;

            // Gain values
            // Mid-band gain (with bypass effective if used)
            const gainMB = rcParallel / (reEffective + reIntrinsic);
            // Low frequency gain (bypass not effective - full Re in circuit)
            const gainLF = bypassMode === 'full' ? rcParallel / (re + reIntrinsic) : gainMB;

            // Magnitude function
            function magnitude(f) {
                // High-pass response from Cin
                const hpIn = f / Math.sqrt(f * f + fcIn * fcIn);
                // High-pass response from Cout
                const hpOut = f / Math.sqrt(f * f + fcOut * fcOut);

                // Low-pass response from transistor HF limitations
                const lpHF = fH / Math.sqrt(f * f + fH * fH);

                // Gain transition due to Ce bypass (only in full bypass mode)
                let gain;
                if (bypassMode === 'full' && fcBypass > 0) {
                    const bypassFactor = f / Math.sqrt(f * f + fcBypass * fcBypass);
                    gain = gainLF + (gainMB - gainLF) * bypassFactor;
                } else {
                    gain = gainMB;
                }

                const result = inputAtten * gain * outputAtten * hpIn * hpOut * lpHF;
                // Ensure we never return 0 or negative (would cause -Infinity in dB)
                return Math.max(result, 1e-10);
            }

            // Find mid-band gain for normalization
            const midF = Math.sqrt(fLow * fH); // Geometric mean of corners
            const midBandGain = magnitude(Math.min(midF, fH / 10));

            // Create graph
            const graph = new Graph({
                xMin: fMin,
                xMax: fMax,
                yMin: -40,
                yMax: 10
            });

            // Generate response curve (normalized to mid-band = 0dB)
            const normFactor = midBandGain > 0 ? midBandGain : 1;
            const curve = generateResponseCurve(fMin, fMax, f => magnitude(f) / normFactor);
            graph.addCurve(curve, { label: 'Response' });

            // Add reference lines
            graph.addHLine(-3, { color: '#f88', label: '-3 dB' });
            graph.addVLine(fLow, { color: '#88f', label: 'fL' });
            if (isFinite(fH) && fH > 0) {
                graph.addVLine(fH, { color: '#8a8', label: 'fH ≈ ' + fmt(fH, 'Hz') });
            }

            return graph.toSVG();
        }

        // Draw input/output waveforms
        function drawWaveforms(params) {
            const { vinPeak, voutPeak, maxSwing, gain } = params;

            const width = 500;
            const height = 200;
            const margin = { top: 30, right: 20, bottom: 30, left: 50 };
            const plotW = width - margin.left - margin.right;
            const plotH = height - margin.top - margin.bottom;

            // Clipping threshold (peak voltage, not p-p)
            const clipLevel = maxSwing / 2;
            const isClipping = voutPeak > clipLevel;

            // Scale: show 2 cycles, normalize to largest signal (fill the graph)
            const maxV = Math.max(vinPeak, isClipping ? clipLevel : voutPeak) * 1.05;
            const cycles = 2;
            const numPoints = 200;

            // Scale functions
            const xScale = (t) => margin.left + (t / cycles) * plotW;
            const yScale = (v) => margin.top + plotH / 2 - (v / maxV) * (plotH / 2);

            let svg = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width: 100%; max-width: ${width}px; height: auto; font-family: monospace; font-size: 11px;">`;

            // Background
            svg += `<rect x="${margin.left}" y="${margin.top}" width="${plotW}" height="${plotH}" fill="#fafafa" stroke="#ccc"/>`;

            // Zero line
            svg += `<line x1="${margin.left}" y1="${yScale(0)}" x2="${margin.left + plotW}" y2="${yScale(0)}" stroke="#ccc" stroke-width="1"/>`;

            // Clip level indicators (if relevant)
            if (isClipping) {
                svg += `<line x1="${margin.left}" y1="${yScale(clipLevel)}" x2="${margin.left + plotW}" y2="${yScale(clipLevel)}" stroke="#c66" stroke-dasharray="4,2"/>`;
                svg += `<line x1="${margin.left}" y1="${yScale(-clipLevel)}" x2="${margin.left + plotW}" y2="${yScale(-clipLevel)}" stroke="#c66" stroke-dasharray="4,2"/>`;
                svg += `<text x="${margin.left + plotW + 5}" y="${yScale(clipLevel) + 4}" fill="#c66" font-size="9">clip</text>`;
                svg += `<text x="${margin.left + plotW + 5}" y="${yScale(-clipLevel) + 4}" fill="#c66" font-size="9">clip</text>`;
            }

            // Generate waveform paths
            let inputPath = '';
            let outputPath = '';

            for (let i = 0; i <= numPoints; i++) {
                const t = (i / numPoints) * cycles;
                const angle = t * 2 * Math.PI;

                // Input: simple sine
                const vin = vinPeak * Math.sin(angle);

                // Output: inverted and amplified, with clipping
                let vout = -voutPeak * Math.sin(angle); // Inverted
                if (isClipping) {
                    vout = Math.max(-clipLevel, Math.min(clipLevel, vout));
                }

                const x = xScale(t);
                const yIn = yScale(vin);
                const yOut = yScale(vout);

                if (i === 0) {
                    inputPath = `M ${x} ${yIn}`;
                    outputPath = `M ${x} ${yOut}`;
                } else {
                    inputPath += ` L ${x} ${yIn}`;
                    outputPath += ` L ${x} ${yOut}`;
                }
            }

            // Draw input waveform
            svg += `<path d="${inputPath}" fill="none" stroke="#88f" stroke-width="2"/>`;

            // Draw output waveform
            svg += `<path d="${outputPath}" fill="none" stroke="#c33" stroke-width="2"/>`;

            // Y-axis labels
            svg += `<text x="${margin.left - 5}" y="${yScale(maxV * 0.8) + 4}" text-anchor="end" font-size="10">+</text>`;
            svg += `<text x="${margin.left - 5}" y="${yScale(-maxV * 0.8) + 4}" text-anchor="end" font-size="10">−</text>`;
            svg += `<text x="${margin.left - 5}" y="${yScale(0) + 4}" text-anchor="end" font-size="10">0</text>`;

            // Legend
            svg += `<line x1="${margin.left + 10}" y1="${margin.top - 15}" x2="${margin.left + 30}" y2="${margin.top - 15}" stroke="#88f" stroke-width="2"/>`;
            svg += `<text x="${margin.left + 35}" y="${margin.top - 11}" font-size="10">Input (${(vinPeak * 1000).toFixed(0)}mV peak)</text>`;

            svg += `<line x1="${margin.left + 180}" y1="${margin.top - 15}" x2="${margin.left + 200}" y2="${margin.top - 15}" stroke="#c33" stroke-width="2"/>`;
            svg += `<text x="${margin.left + 205}" y="${margin.top - 11}" font-size="10">Output (${(Math.min(voutPeak, clipLevel) * 1000).toFixed(0)}mV peak${isClipping ? ', clipped' : ''})</text>`;

            // Phase inversion note
            svg += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle" fill="#666" font-size="10">180° phase inversion</text>`;

            svg += '</svg>';
            return svg;
        }

        // Draw DC load line with Q-point and optional AC load line
        function drawLoadLine(params) {
            const { vcc, rc, re, ic, vce, veMin, rload } = params;

            const width = 500;
            const height = 300;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const plotW = width - margin.left - margin.right;
            const plotH = height - margin.top - margin.bottom;

            // DC Load line endpoints
            // At Ic = 0: Vce = Vcc (cutoff)
            // At Vce = 0: Ic = Vcc / (Rc + Re) (saturation)
            const icSat = vcc / (rc + re); // mA
            const vceCutoff = vcc;

            // AC load line (only if there's a load resistor)
            // AC load = Rc || Rload (in kΩ for mA calculations)
            const hasAcLoad = rload && isFinite(rload) && rload > 0;
            const rac = hasAcLoad ? (rc * rload) / (rc + rload) : rc; // Rc || Rload in kΩ

            // AC load line passes through Q-point with slope -1/Rac
            // Ic = ic + (vce - Vce) / Rac
            const acIcAtVce0 = ic + vce / rac; // Ic intercept when Vce = 0
            const acVceAtIc0 = vce + ic * rac; // Vce intercept when Ic = 0

            // Axis ranges (add some padding, account for AC load line)
            const vceMax = Math.max(vceCutoff, acVceAtIc0) * 1.1;
            const icMax = Math.max(icSat, acIcAtVce0) * 1.1;

            // Scale functions
            const xScale = (v) => margin.left + (v / vceMax) * plotW;
            const yScale = (i) => margin.top + plotH - (i / icMax) * plotH;

            let svg = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width: 100%; max-width: ${width}px; height: auto; font-family: monospace; font-size: 11px;">`;

            // Background
            svg += `<rect x="${margin.left}" y="${margin.top}" width="${plotW}" height="${plotH}" fill="#fafafa" stroke="#ccc"/>`;

            // Grid lines
            const vceStep = Math.ceil(vceMax / 5);
            for (let v = 0; v <= vceMax; v += vceStep) {
                const x = xScale(v);
                svg += `<line x1="${x}" y1="${margin.top}" x2="${x}" y2="${margin.top + plotH}" stroke="#ddd"/>`;
                svg += `<text x="${x}" y="${height - 25}" text-anchor="middle">${v.toFixed(0)}</text>`;
            }
            const icStep = Math.ceil(icMax * 10) / 50; // Nice steps in mA
            for (let i = 0; i <= icMax; i += icStep) {
                const y = yScale(i);
                svg += `<line x1="${margin.left}" y1="${y}" x2="${margin.left + plotW}" y2="${y}" stroke="#ddd"/>`;
                svg += `<text x="${margin.left - 5}" y="${y + 4}" text-anchor="end">${i.toFixed(1)}</text>`;
            }

            // Axis labels
            svg += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle">Vce (V)</text>`;
            svg += `<text x="15" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 15, ${height / 2})">Ic (mA)</text>`;

            // Saturation region (Vce < ~0.3V)
            const vcesat = 0.3;
            svg += `<rect x="${margin.left}" y="${margin.top}" width="${xScale(vcesat) - margin.left}" height="${plotH}" fill="#fee" opacity="0.5"/>`;
            svg += `<text x="${xScale(vcesat/2)}" y="${margin.top + 15}" text-anchor="middle" fill="#c66" font-size="9">Saturation</text>`;

            // DC Load line
            svg += `<line x1="${xScale(0)}" y1="${yScale(icSat)}" x2="${xScale(vceCutoff)}" y2="${yScale(0)}" stroke="#2266cc" stroke-width="2"/>`;
            svg += `<text x="${xScale(vceCutoff * 0.7)}" y="${yScale(icSat * 0.3) - 5}" fill="#2266cc" font-size="10">DC Load Line</text>`;

            // AC Load line (if there's a load - steeper slope through Q-point)
            if (hasAcLoad) {
                // Clamp to visible area
                const acX1 = Math.max(0, 0);
                const acY1 = Math.min(acIcAtVce0, icMax);
                const acX2 = Math.min(acVceAtIc0, vceMax);
                const acY2 = Math.max(0, 0);

                svg += `<line x1="${xScale(acX1)}" y1="${yScale(acY1)}" x2="${xScale(acX2)}" y2="${yScale(acY2)}" stroke="#e80" stroke-width="2" stroke-dasharray="6,3"/>`;
                svg += `<text x="${xScale(acVceAtIc0 * 0.8)}" y="${yScale(acIcAtVce0 * 0.15) + 12}" fill="#e80" font-size="10">AC Load Line</text>`;
            }

            // Label DC load line endpoints
            svg += `<text x="${xScale(vceCutoff) + 5}" y="${yScale(0) + 4}" fill="#2266cc" font-size="10">Cutoff</text>`;

            // Q-point
            const qX = xScale(vce);
            const qY = yScale(ic);
            svg += `<circle cx="${qX}" cy="${qY}" r="6" fill="#c33" stroke="#fff" stroke-width="2"/>`;
            svg += `<text x="${qX + 10}" y="${qY - 10}" fill="#c33" font-weight="bold">Q-point</text>`;
            svg += `<text x="${qX + 10}" y="${qY + 5}" fill="#c33" font-size="10">(${vce.toFixed(1)}V, ${ic.toFixed(2)}mA)</text>`;

            // Show swing limits with dashed lines
            // Vce can't go below Vce_sat (~0.3V) or above Vcc - Ve
            const vceSat = 0.3;
            const swingDown = vce - vceSat;
            const swingUp = (vcc - veMin) - vce; // Max Vce at cutoff is approximately Vcc - Ve
            const swing = Math.min(swingDown, swingUp);

            if (swing > 0) {
                // Swing range markers
                const vceSwingLow = vce - swing;
                const vceSwingHigh = vce + swing;

                // Calculate Ic at swing limits (on the load line)
                // ΔIc = ΔVce / (Rc + Re), with Rc+Re in kΩ gives ΔIc in mA
                const icSwingLow = ic + swing / (rc + re); // Ic increases as Vce decreases
                const icSwingHigh = ic - swing / (rc + re);

                // Draw swing envelope
                svg += `<line x1="${xScale(vceSwingLow)}" y1="${margin.top}" x2="${xScale(vceSwingLow)}" y2="${margin.top + plotH}" stroke="#3a3" stroke-dasharray="4,2"/>`;
                svg += `<line x1="${xScale(vceSwingHigh)}" y1="${margin.top}" x2="${xScale(vceSwingHigh)}" y2="${margin.top + plotH}" stroke="#3a3" stroke-dasharray="4,2"/>`;

                // Swing annotation
                svg += `<text x="${xScale(vce)}" y="${margin.top + plotH - 10}" text-anchor="middle" fill="#3a3" font-size="10">← Swing: ${(swing * 2).toFixed(1)}V p-p →</text>`;
            }

            // Saturation limit line
            svg += `<line x1="${xScale(vceSat)}" y1="${margin.top}" x2="${xScale(vceSat)}" y2="${margin.top + plotH}" stroke="#c66" stroke-dasharray="2,2"/>`;

            svg += '</svg>';
            return svg;
        }

        function calculate() {
            const vcc = parseFloat(document.getElementById('vcc').value);
            const targetGain = parseFloat(document.getElementById('gain').value);
            const vin = parseFloat(document.getElementById('vin').value) / 1000;
            const zsource = parseFloat(document.getElementById('zsource').value);
            const fLow = parseFloat(document.getElementById('fLow').value);
            const rloadInput = document.getElementById('rload').value;
            const rload = rloadInput ? parseFloat(rloadInput) : Infinity;
            const bypassMode = document.getElementById('bypassMode').value;
            const ic = parseFloat(document.getElementById('ic').value) / 1000; // mA to A
            const beta = parseFloat(document.getElementById('beta').value);
            const fT = parseFloat(document.getElementById('ft').value) * 1e6; // MHz to Hz

            // Biasing: set Ve for stability, calculate operating point
            const ve = Math.max(vcc * 0.1, 1.0);
            const vb = ve + 0.7;
            const reIntrinsic = 0.026 / ic;

            // Re is fixed by biasing
            const re = ve / ic;

            // Calculate Rc to achieve desired gain
            // Av = Rc / (Re_effective + re')
            // For unbypassed: Re_effective = Re
            // For bypassed: Re_effective = 0 (only re' remains)
            let rc, reEffective;
            if (bypassMode === 'full') {
                // Full bypass: gain is Rc/re', solve for Rc
                rc = targetGain * reIntrinsic;
                reEffective = 0;
            } else {
                // No bypass: gain is Rc/(Re + re'), solve for Rc
                rc = targetGain * (re + reIntrinsic);
                reEffective = re;
            }

            // Check if Rc is feasible
            const vc = vcc - ic * rc;
            const vcMin = ve + 0.3; // Minimum Vc for active region
            let notes = [];

            if (vc < vcMin) {
                // Rc is too large, clamp it
                rc = (vcc - vcMin) / ic;
                const actualGain = rc / (reEffective + reIntrinsic);
                notes.push('Gain limited to ' + actualGain.toFixed(1) + 'x. To achieve higher gain: increase Vcc, increase Ic, or use bypass mode.');
            }

            // Bias resistors
            const ib = ic / beta;
            const idivider = ib * 10;
            const rtotal = vcc / idivider;
            const r2 = (vb / vcc) * rtotal;
            const r1 = rtotal - r2;

            // Round resistors to E24 values
            const r1Rounded = roundToE24(r1);
            const r2Rounded = roundToE24(r2);
            const rcRounded = roundToE24(rc);
            const reRounded = roundToE24(re);

            // Calculate actual transistor gain with rounded values
            const reEffectiveRounded = bypassMode === 'full' ? 0 : reRounded;
            const transGain = rcRounded / (reEffectiveRounded + reIntrinsic);

            // Input impedance depends on what's in the emitter
            const zinBase = beta * (reEffectiveRounded + reIntrinsic);
            const zin = parallel(r1Rounded, r2Rounded, zinBase);

            // Output impedance is approximately Rc
            const zout = rcRounded;

            // Attenuation factors
            const inputAtten = zsource > 0 ? zin / (zin + zsource) : 1;
            const outputAtten = isFinite(rload) ? rload / (rload + rcRounded) : 1;

            // Effective gain (what you actually get)
            const effectiveGain = inputAtten * transGain * outputAtten;
            const voutPeak = vin * effectiveGain;

            // Capacitors
            const fcorner = fLow / 10;
            const cinCalc = 1 / (2 * Math.PI * fcorner * zin);
            const coutCalc = isFinite(rload) ? 1 / (2 * Math.PI * fcorner * rload) : 1e-6;
            const ceCalc = bypassMode === 'full' ? 10 / (2 * Math.PI * fLow * reRounded) : 0;

            const cinRounded = roundCap(cinCalc);
            const coutRounded = roundCap(coutCalc);
            const ceRounded = ceCalc > 0 ? roundCap(ceCalc) : 0;

            // Recalculate Vc with rounded Rc
            const vcActual = vcc - ic * rcRounded;
            const swingUp = vcc - vcActual;
            const swingDown = vcActual - vcMin;
            const maxSwing = Math.min(swingUp, swingDown) * 2;

            // Warnings
            const warn = document.getElementById('warning');
            let warnings = [];
            if (vcActual < vcMin) {
                warnings.push('<b>Biasing problem:</b> Vc (' + vcActual.toFixed(1) + 'V) is too close to Ve (' + ve.toFixed(1) + 'V). The transistor needs voltage headroom between collector and emitter to amplify. Try lowering the gain, increasing Vcc, or using bypass mode.');
            } else if (voutPeak * 2 > maxSwing) {
                warnings.push('<b>Clipping warning:</b> Your expected output (' + (voutPeak * 2).toFixed(2) + 'V p-p) exceeds the available swing (' + maxSwing.toFixed(2) + 'V p-p). The output waveform will be distorted. Try reducing the input level or lowering the gain.');
            }
            if (warnings.length > 0) {
                warn.innerHTML = warnings.join('<br><br>');
                warn.classList.remove('hidden');
            } else {
                warn.classList.add('hidden');
            }

            // Results
            document.getElementById('results').style.display = 'block';

            // Draw schematic
            document.getElementById('schematic').innerHTML = drawSchematic({
                r1: fmt(r1Rounded, 'Ω'),
                r2: fmt(r2Rounded, 'Ω'),
                rc: fmt(rcRounded, 'Ω'),
                re: fmt(reRounded, 'Ω'),
                cin: fmt(cinRounded, 'F'),
                cout: fmt(coutRounded, 'F'),
                ce: ceRounded > 0 ? fmt(ceRounded, 'F') : null,
                rload: isFinite(rload) ? fmt(rload, 'Ω') : null,
                vb: fmt(vb, 'V'),
                ve: fmt(ve, 'V'),
                vc: fmt(vcActual, 'V'),
                ic: fmt(ic * 1000, 'mA'),
                swing: fmt(maxSwing, 'V') + ' p-p',
                transGain: transGain.toFixed(1) + 'x',
                effectiveGain: effectiveGain.toFixed(1) + 'x',
                bypassMode: bypassMode
            });

            // Table values
            document.getElementById('r1').textContent = fmtLong(r1Rounded, 'Ω');
            document.getElementById('r2').textContent = fmtLong(r2Rounded, 'Ω');
            document.getElementById('rc').textContent = fmtLong(rcRounded, 'Ω');
            document.getElementById('re').textContent = fmtLong(reRounded, 'Ω');
            document.getElementById('cin').textContent = fmtLong(cinRounded, 'F');
            document.getElementById('cout').textContent = fmtLong(coutRounded, 'F');
            document.getElementById('ce').textContent = ceRounded > 0 ? fmtLong(ceRounded, 'F') : 'not used';
            document.getElementById('note').textContent = notes.join(' ');

            // Gain analysis
            document.getElementById('zin').textContent = fmtLong(zin, 'Ω');
            document.getElementById('zout').textContent = fmtLong(zout, 'Ω');
            document.getElementById('transGain').textContent = transGain.toFixed(1) + 'x';
            document.getElementById('inputAtten').textContent = zsource > 0 ? (inputAtten * 100).toFixed(1) + '%' : '100% (no source Z)';
            document.getElementById('outputAtten').textContent = isFinite(rload) ? (outputAtten * 100).toFixed(1) + '%' : '100% (no load)';
            document.getElementById('effectiveGain').textContent = effectiveGain.toFixed(1) + 'x';
            document.getElementById('expectedOut').textContent = (voutPeak * 1000).toFixed(0) + ' mV peak';

            // Draw input/output waveforms
            document.getElementById('waveforms').innerHTML = drawWaveforms({
                vinPeak: vin,
                voutPeak: voutPeak,
                maxSwing: maxSwing,
                gain: effectiveGain
            });

            // Draw DC load line (and AC load line if there's a load)
            document.getElementById('loadLine').innerHTML = drawLoadLine({
                vcc: vcc,
                rc: rcRounded / 1000, // Convert to kΩ for mA calculation
                re: reRounded / 1000,
                ic: ic * 1000, // Convert A to mA
                vce: vcActual - ve, // Vce = Vc - Ve
                veMin: ve,
                rload: isFinite(rload) ? rload / 1000 : null // Convert to kΩ
            });

            // Draw frequency response
            document.getElementById('freqResponse').innerHTML = drawFrequencyResponse({
                zin: zin,
                zsource: zsource,
                rc: rcRounded,
                re: reRounded,
                reEffective: reEffectiveRounded,
                reIntrinsic: reIntrinsic,
                rload: rload,
                cin: cinRounded,
                cout: coutRounded,
                ce: ceRounded,
                beta: beta,
                fLow: fLow,
                fT: fT,
                bypassMode: bypassMode
            });
        }
        function resetDefaults() {
            document.getElementById('vcc').value = '10';
            document.getElementById('gain').value = '5';
            document.getElementById('vin').value = '100';
            document.getElementById('zsource').value = '0';
            document.getElementById('fLow').value = '20';
            document.getElementById('rload').value = '';
            document.getElementById('bypassMode').value = 'none';
            document.getElementById('ic').value = '1';
            document.getElementById('beta').value = '100';
            document.getElementById('ft').value = '150';
            calculate();
        }

        window.onload = calculate;
    </script>
</body>
</html>
