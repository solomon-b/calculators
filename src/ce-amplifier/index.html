<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CE Amplifier Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
    tailwind.config = {
        theme: {
            extend: {
                colors: {
                    primary: '#2266cc',
                }
            }
        }
    }
    </script>
    <style>
        /* Styles for dynamically generated SVG */
        svg text { font-family: ui-monospace, monospace; }
    </style>
</head>
<body class="max-w-3xl mx-auto px-4 sm:px-6 py-8 font-sans leading-relaxed">
    <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-4">CE Amplifier Calculator</h1>
    <p class="text-gray-600 text-lg max-w-xl mb-6">
        Design a common-emitter amplifier with voltage divider biasing.
        This topology trades some gain for stable, predictable operation across transistor variations.
    </p>

    <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Inputs</h2>
    <div class="overflow-x-auto">
        <table class="w-full sm:w-auto">
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Supply voltage for the amplifier">Vcc:</td>
                <td class="py-2"><input type="number" id="vcc" value="10" step="0.1" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> V</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Voltage gain of the transistor stage (Vout/Vin)">Desired gain (Av):</td>
                <td class="py-2"><input type="number" id="gain" value="5" step="1" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> V/V</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Peak amplitude of your input signal (used to check for clipping)">Input (peak):</td>
                <td class="py-2"><input type="number" id="vin" value="100" step="10" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> mV</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Output impedance of whatever drives this amplifier. Higher values reduce effective gain.">Source impedance:</td>
                <td class="py-2"><input type="number" id="zsource" value="0" step="100" min="0" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> &#8486;</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Lowest frequency you need to amplify. Sets the coupling capacitor sizes.">Low frequency (-3dB):</td>
                <td class="py-2"><input type="number" id="fLow" value="20" step="1" min="1" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> Hz</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Resistance of whatever this amplifier drives. Lower values reduce effective gain. Leave empty for open circuit.">Load (optional):</td>
                <td class="py-2"><input type="number" id="rload" value="" placeholder="&#8734;" step="1000" min="100" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> &#8486;</td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Bypassing Re with a capacitor increases AC gain but makes it less predictable and more dependent on transistor parameters.">Bypass Re:</td>
                <td class="py-2">
                    <select id="bypassMode" class="px-2 py-1 border border-gray-300 rounded text-sm">
                        <option value="none">No bypass (stable gain)</option>
                        <option value="full">Full bypass (max gain)</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="DC current through the collector. Higher values give more bandwidth but use more power.">Collector current (Ic):</td>
                <td class="py-2"><input type="number" id="ic" value="1" step="0.5" min="0.1" max="20" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm"> mA</td>
            </tr>
        </table>
    </div>

    <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Transistor Selection</h2>
    <div class="overflow-x-auto">
        <table class="w-full sm:w-auto">
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Select a real transistor to see practical limitations, or Ideal for theoretical behavior with infinite β and bandwidth.">Transistor:</td>
                <td class="py-2">
                    <select id="transistorPreset" onchange="updateTransistorFields()" class="px-2 py-1 border border-gray-300 rounded text-sm">
                        <option value="ideal" selected>Ideal</option>
                        <option value="2n2222">2N2222</option>
                        <option value="2n3904">2N3904</option>
                        <option value="bc547">BC547</option>
                        <option value="2n5551">2N5551</option>
                        <option value="mpsa18">MPSA18</option>
                        <option value="custom">Custom...</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Current gain (Ic/Ib). Higher β means less base current needed, higher input impedance. Ideal assumes very high β.">&#946; (hFE):</td>
                <td class="py-2"><input type="text" id="beta" value="∞" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm bg-gray-100 text-gray-500" disabled></td>
            </tr>
            <tr>
                <td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Transition frequency - where β drops to 1. Limits high-frequency gain. fβ = fT/β is where gain starts rolling off.">fT:</td>
                <td class="py-2"><input type="text" id="ft" value="∞" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm bg-gray-100 text-gray-500" disabled> MHz</td>
            </tr>
        </table>
    </div>
    <p class="text-sm text-gray-400 mt-2">Hover over labels for explanations.</p>
    <div class="flex flex-wrap gap-2 mt-4">
        <button onclick="calculate()" class="px-5 py-2 bg-primary text-white rounded hover:bg-blue-700 cursor-pointer text-sm">Calculate</button>
        <button onclick="resetDefaults()" class="px-5 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 cursor-pointer text-sm">Reset</button>
        <button onclick="openInFalstad()" class="px-5 py-2 bg-green-600 text-white rounded hover:bg-green-700 cursor-pointer text-sm">Open in Falstad</button>
    </div>

    <div id="warning" class="hidden text-red-700 bg-red-50 border-l-4 border-red-600 p-4 my-4"></div>

    <div id="results">
        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Schematic</h2>
        <div id="schematic" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Calculated Values</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            Component values rounded to standard E24 series. The bias resistors (R1, R2) set the DC operating point.
        </p>
        <div class="overflow-x-auto">
            <table class="w-full sm:w-auto">
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Upper bias resistor, sets base voltage together with R2">R1 (upper bias):</td><td id="r1" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Lower bias resistor, forms voltage divider with R1">R2 (lower bias):</td><td id="r2" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Collector resistor, converts collector current changes to voltage changes">Rc (collector):</td><td id="rc" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Emitter resistor, provides negative feedback for stability. Gain &#8776; Rc/Re">Re (emitter):</td><td id="re" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Input coupling capacitor, blocks DC while passing AC signal">Cin (input):</td><td id="cin" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Output coupling capacitor, blocks DC bias from reaching the load">Cout (output):</td><td id="cout" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Emitter bypass capacitor, shorts Re at AC frequencies to increase gain">Ce (bypass):</td><td id="ce" class="py-2 text-right font-mono"></td></tr>
            </table>
        </div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Gain Analysis</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The gain you actually get depends on source and load impedances. The transistor provides its gain,
            but some signal is lost at the input (voltage divider with source impedance) and output (voltage divider with load).
        </p>
        <div class="overflow-x-auto">
            <table class="w-full sm:w-auto">
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="How much resistance the amplifier presents to the signal source. Higher is generally better.">Input impedance (Zin):</td><td id="zin" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="How much resistance the amplifier presents to its load. Lower means it can drive heavier loads.">Output impedance (Zout):</td><td id="zout" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="The gain of the transistor stage itself: Rc / (Re + re')">Transistor gain (Av):</td><td id="transGain" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Signal loss at input due to source impedance. Zin / (Zin + Zsource)">Input attenuation:</td><td id="inputAtten" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Signal loss at output due to load. Rload / (Rload + Zout)">Output attenuation:</td><td id="outputAtten" class="py-2 text-right font-mono"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400 font-bold" title="What you actually measure: transistor gain &#215; input attenuation &#215; output attenuation">Effective gain:</td><td id="effectiveGain" class="py-2 text-right font-mono font-bold"></td></tr>
                <tr><td class="py-2 pr-4 cursor-help border-b border-dotted border-gray-400" title="Peak output voltage based on input level and effective gain">Expected output:</td><td id="expectedOut" class="py-2 text-right font-mono"></td></tr>
            </table>
        </div>

        <p id="note" class="text-amber-600 mt-4"></p>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Input / Output Waveforms</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The CE amplifier inverts the signal (180&#176; phase shift) and amplifies it.
            If the output exceeds the available swing, it clips (flattens) at the peaks.
        </p>
        <div id="waveforms" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Load Lines</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            The DC load line (solid blue) shows the operating path set by Rc + Re.
            When a load is connected, the AC load line (dashed orange) is steeper because AC sees Rc || Rload.
            The Q-point (red dot) sits on both lines. The green dashed lines show the maximum swing limits before clipping - left is saturation, right is cutoff. For maximum undistorted output, the Q-point should be centered between these limits.
        </p>
        <div id="loadLine" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Frequency Response</h2>
        <p class="text-sm text-gray-600 mb-3 max-w-xl">
            Low frequencies are limited by coupling capacitors (Cin, Cout) and bypass capacitor (Ce).
            High frequencies are limited by the transistor's internal capacitances and &#946; rolloff.
        </p>
        <div id="freqResponse" class="overflow-x-auto"></div>

        <h2 class="text-xl font-semibold text-gray-600 mt-8 mb-4">Design Formulas</h2>
        <details class="my-4" id="designDetails">
            <summary class="cursor-pointer text-primary font-bold">Click to show step-by-step design procedure</summary>
            <div class="mt-4 p-4 bg-gray-100 rounded text-sm">
                <h3 class="text-base font-semibold text-gray-600 mt-0 mb-2">Step 1: Set the DC Operating Point</h3>
                <p>Choose emitter voltage for thermal stability (typically 10% of Vcc or 1V minimum):</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    V<sub>E</sub> = max(0.1 &#215; V<sub>CC</sub>, 1V)<br>
                    V<sub>B</sub> = V<sub>E</sub> + 0.7V
                </code>
                <div id="calc-step1" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 2: Calculate Emitter Resistor</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    R<sub>E</sub> = V<sub>E</sub> / I<sub>C</sub>
                </code>
                <div id="calc-step2" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 3: Calculate Intrinsic Emitter Resistance</h3>
                <p>This is the transistor's internal resistance, temperature dependent (V<sub>T</sub> = kT/q &#8776; 26mV at 25&#176;C):</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    r<sub>e</sub>' = V<sub>T</sub> / I<sub>C</sub> = 26mV / I<sub>C</sub>
                </code>
                <div id="calc-step3" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 4: Calculate Collector Resistor for Desired Gain</h3>
                <p><b>Without bypass (stable gain):</b></p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    A<sub>v</sub> = R<sub>C</sub> / (R<sub>E</sub> + r<sub>e</sub>')<br>
                    &#8756; R<sub>C</sub> = A<sub>v</sub> &#215; (R<sub>E</sub> + r<sub>e</sub>')
                </code>
                <p><b>With full bypass (maximum gain):</b></p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    A<sub>v</sub> = R<sub>C</sub> / r<sub>e</sub>'<br>
                    &#8756; R<sub>C</sub> = A<sub>v</sub> &#215; r<sub>e</sub>'
                </code>
                <div id="calc-step4" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 5: Verify Operating Point</h3>
                <p>Check that V<sub>C</sub> leaves room for the transistor to operate:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    V<sub>C</sub> = V<sub>CC</sub> - I<sub>C</sub> &#215; R<sub>C</sub><br>
                    Requirement: V<sub>C</sub> > V<sub>E</sub> + 0.3V (active region)
                </code>
                <div id="calc-step5" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 6: Calculate Bias Resistors</h3>
                <p>Use the "stiff divider" rule - divider current should be ~10&#215; base current:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    I<sub>B</sub> = I<sub>C</sub> / &#946;<br>
                    I<sub>divider</sub> = 10 &#215; I<sub>B</sub><br>
                    R<sub>total</sub> = V<sub>CC</sub> / I<sub>divider</sub><br>
                    R<sub>2</sub> = (V<sub>B</sub> / V<sub>CC</sub>) &#215; R<sub>total</sub><br>
                    R<sub>1</sub> = R<sub>total</sub> - R<sub>2</sub>
                </code>
                <div id="calc-step6" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 7: Calculate Input Impedance</h3>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    Z<sub>in(base)</sub> = &#946; &#215; (R<sub>E</sub> + r<sub>e</sub>') &nbsp;&nbsp;<i>[without bypass]</i><br>
                    Z<sub>in(base)</sub> = &#946; &#215; r<sub>e</sub>' &nbsp;&nbsp;<i>[with bypass]</i><br>
                    Z<sub>in</sub> = R<sub>1</sub> &#8741; R<sub>2</sub> &#8741; Z<sub>in(base)</sub>
                </code>
                <div id="calc-step7" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 8: Calculate Coupling Capacitors</h3>
                <p>Size for -3dB at the desired low frequency cutoff:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    C<sub>in</sub> = 1 / (2&#960; &#215; f<sub>low</sub> &#215; Z<sub>in</sub>)<br>
                    C<sub>out</sub> = 1 / (2&#960; &#215; f<sub>low</sub> &#215; R<sub>load</sub>)
                </code>
                <div id="calc-step8" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 9: Calculate Bypass Capacitor (if used)</h3>
                <p>Must have low impedance at lowest frequency of interest:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    X<sub>Ce</sub> << R<sub>E</sub> at f<sub>low</sub><br>
                    C<sub>E</sub> &#8776; 10 / (2&#960; &#215; f<sub>low</sub> &#215; R<sub>E</sub>)
                </code>
                <div id="calc-step9" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Step 10: Calculate Effective Gain</h3>
                <p>Account for loading at input and output:</p>
                <code class="block bg-white p-2 my-2 border border-gray-200 rounded">
                    Input attenuation = Z<sub>in</sub> / (Z<sub>in</sub> + Z<sub>source</sub>)<br>
                    Output attenuation = R<sub>load</sub> / (R<sub>load</sub> + R<sub>C</sub>)<br>
                    Effective gain = A<sub>v</sub> &#215; input atten &#215; output atten
                </code>
                <div id="calc-step10" class="bg-blue-50 p-2 my-2 border border-blue-200 rounded font-mono"></div>

                <h3 class="text-base font-semibold text-gray-600 mt-4 mb-2">Key Relationships</h3>
                <ul class="list-disc ml-5 space-y-1">
                    <li><b>Output impedance:</b> Z<sub>out</sub> &#8776; R<sub>C</sub></li>
                    <li><b>Voltage swing:</b> Limited by V<sub>C</sub> &#8722; V<sub>E</sub> (down) and V<sub>CC</sub> &#8722; V<sub>C</sub> (up)</li>
                    <li><b>AC load line slope:</b> &#8722;1/(R<sub>C</sub> &#8741; R<sub>load</sub>)</li>
                    <li><b>DC load line slope:</b> &#8722;1/(R<sub>C</sub> + R<sub>E</sub>)</li>
                </ul>
            </div>
        </details>
    </div>

    <script src="../common.js"></script>
    <script src="../schematic.js"></script>
    <script src="../graph.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <script>
        function updateTransistorFields() {
            const preset = document.getElementById('transistorPreset').value;
            const isCustom = preset === 'custom';
            const betaEl = document.getElementById('beta');
            const ftEl = document.getElementById('ft');

            // Enable/disable fields based on custom selection
            betaEl.disabled = !isCustom;
            ftEl.disabled = !isCustom;

            // Update field styling
            betaEl.classList.toggle('bg-gray-100', !isCustom);
            betaEl.classList.toggle('text-gray-500', !isCustom);
            ftEl.classList.toggle('bg-gray-100', !isCustom);
            ftEl.classList.toggle('text-gray-500', !isCustom);

            // Populate values from preset
            if (preset === 'ideal') {
                betaEl.value = '100';
                ftEl.value = '300';
            } else if (preset !== 'custom' && typeof BJT_PRESETS !== 'undefined' && BJT_PRESETS[preset]) {
                const p = BJT_PRESETS[preset];
                betaEl.value = p.beta;
                ftEl.value = (p.ft / 1e6).toFixed(0);
            }
        }

        function getTransistorParams() {
            const preset = document.getElementById('transistorPreset').value;

            if (preset === 'ideal') {
                return { beta: 100, ft: 300e6, vceSat: 0, isIdeal: true };
            }

            if (preset !== 'custom' && BJT_PRESETS[preset]) {
                const p = BJT_PRESETS[preset];
                return { beta: p.beta, ft: p.ft, vceSat: p.vceSat, isIdeal: false };
            }

            // Custom values
            return {
                beta: parseFloat(document.getElementById('beta').value),
                ft: parseFloat(document.getElementById('ft').value) * 1e6,
                vceSat: 0.3,
                isIdeal: false
            };
        }

        function drawSchematic(vals) {
            const sch = new Schematic(450, 420);
            const hasBypass = vals.ce !== null;
            const hasLoad = vals.rload !== null;

            // Transistor at center
            sch.place('npn', 'Q1', 200, 160);

            // Rc (collector resistor)
            sch.place('resistor-v', 'Rc', 225, 75, { label: vals.rc });

            // Re (single emitter resistor) - label on left if bypass cap present
            sch.place('resistor-v', 'Re', 225, 230, { label: vals.re, labelPos: hasBypass ? 'left' : 'right' });

            // Ce bypass cap (only if bypass mode)
            if (hasBypass) {
                sch.place('capacitor-v', 'Ce', 280, 230, { label: vals.ce });
            }

            // Bias resistors
            sch.place('resistor-v', 'R1', 130, 80, { label: vals.r1 });
            sch.place('resistor-v', 'R2', 130, 195, { label: vals.r2 });

            // Cin input cap
            sch.place('capacitor-h', 'Cin', 70, 160, { label: vals.cin });

            // Cout output cap
            sch.place('capacitor-h', 'Cout', 290, 110, { label: vals.cout });

            // Load resistor (dashed - external, only if specified)
            if (hasLoad) {
                sch.place('resistor-v', 'Rload', 350, 165, { label: vals.rload, dashed: true });
                sch.place('ground', 'GND3', 350, 210, { dashed: true });
            }

            // Grounds
            sch.place('ground', 'GND1', 130, 240);
            sch.place('ground', 'GND2', 225, 290);

            // --- Wiring ---

            // Vcc rail
            sch.label('Vcc', 225, 25, { anchor: 'middle' });
            sch.wire({ x: 225, y: 30 }, 'Rc.a');
            sch.wire({ x: 130, y: 30 }, { x: 225, y: 30 });
            sch.wire({ x: 130, y: 30 }, 'R1.a');

            // Rc to collector
            sch.wire('Rc.b', { x: 225, y: 110 });
            sch.node(225, 110);

            // Collector to output cap
            sch.wire({ x: 225, y: 110 }, { x: 225, y: 135 });
            sch.wire({ x: 225, y: 110 }, { x: 286, y: 110 });
            sch.wire('Cout.b', { x: 320, y: 110 });

            if (hasLoad) {
                sch.wire({ x: 320, y: 110 }, { x: 350, y: 110 });
                sch.node(350, 110);
                sch.wire({ x: 350, y: 110 }, 'Rload.a', { dashed: true });
                sch.wire('Rload.b', 'GND3.a', { dashed: true });
            }
            sch.label('Out', hasLoad ? 360 : 330, 114);

            // Emitter wiring
            sch.wire('Q1.emitter', { x: 225, y: 195 });
            sch.wire({ x: 225, y: 195 }, 'Re.a');
            sch.wire('Re.b', { x: 225, y: 275 });
            sch.node(225, 275);
            sch.wire({ x: 225, y: 275 }, 'GND2.a');

            // Ce bypass parallel to Re (if present)
            if (hasBypass) {
                sch.wire({ x: 225, y: 195 }, { x: 280, y: 195 });
                sch.wire({ x: 280, y: 195 }, 'Ce.a');
                sch.wire('Ce.b', { x: 280, y: 275 });
                sch.wire({ x: 280, y: 275 }, { x: 225, y: 275 });
            }

            // Bias network
            sch.wire('R1.b', { x: 130, y: 160 });
            sch.node(130, 160);
            sch.wire({ x: 130, y: 160 }, 'R2.a');
            sch.wire('R2.b', 'GND1.a');

            // Base connection
            sch.wire({ x: 130, y: 160 }, 'Cin.b');
            sch.wire('Cin.a', { x: 40, y: 160 });
            sch.label('In', 25, 164);
            sch.wire({ x: 130, y: 160 }, 'Q1.base');

            // Info display
            sch.label('Operating Point:', 20, 330, { bold: true });
            sch.label('Vb = ' + vals.vb, 20, 350);
            sch.label('Ve = ' + vals.ve, 20, 370);
            sch.label('Vc = ' + vals.vc, 20, 390);
            sch.label('Ic = ' + vals.ic, 130, 350);
            sch.label('Swing = ' + vals.swing, 130, 370);

            sch.label('Gain:', 260, 330, { bold: true });
            sch.label('Transistor: ' + vals.transGain, 260, 350);
            sch.label('Effective: ' + vals.effectiveGain, 260, 370);

            return sch.toSVG();
        }

        // Calculate CE amplifier frequency response
        function drawFrequencyResponse(params) {
            const { zin, zsource, rc, re, reEffective, reIntrinsic, rload, cin, cout, ce, beta, fLow, fT, bypassMode } = params;

            // Frequency range: 1Hz to 100MHz
            const fMin = 1;
            const fMax = 100000000;

            // Handle infinite load and ensure positive values
            const rloadEff = (isFinite(rload) && rload > 0) ? rload : 1e9;
            const zinEff = zin > 0 ? zin : 1000;

            // Corner frequencies for each high-pass stage
            const fcIn = 1 / (2 * Math.PI * cin * (zsource + zinEff));
            const fcOut = 1 / (2 * Math.PI * cout * (rc + rloadEff));
            const fcBypass = (bypassMode === 'full' && ce > 0 && re > 0) ? 1 / (2 * Math.PI * ce * re) : 0;

            // High-frequency limitations
            // fβ is where β starts rolling off
            const fBeta = fT / beta;

            // Effective load for gain calculation
            const rcParallel = parallel(rc, rloadEff);

            // Miller effect: Cbc (typ ~2pF) multiplied by voltage gain
            // Creates dominant high-frequency pole
            const Cbc = 2e-12; // Typical collector-base capacitance
            const Av = rcParallel / (reEffective + reIntrinsic); // Voltage gain
            const Cmiller = Cbc * (1 + Av);

            // High-frequency pole from Miller + source impedance
            const rSource = zsource > 0 ? parallel(zsource, zinEff) : zinEff;
            const fHmiller = 1 / (2 * Math.PI * rSource * Cmiller);

            // Combined high-frequency pole (use dominant one)
            const fH = Math.min(fBeta, fHmiller);

            // Input and output attenuation (constant with frequency)
            const inputAtten = zsource > 0 ? zinEff / (zinEff + zsource) : 1;
            const outputAtten = isFinite(rload) ? rload / (rload + rc) : 1;

            // Gain values
            // Mid-band gain (with bypass effective if used)
            const gainMB = rcParallel / (reEffective + reIntrinsic);
            // Low frequency gain (bypass not effective - full Re in circuit)
            const gainLF = bypassMode === 'full' ? rcParallel / (re + reIntrinsic) : gainMB;

            // Magnitude function
            function magnitude(f) {
                // High-pass response from Cin
                const hpIn = f / Math.sqrt(f * f + fcIn * fcIn);
                // High-pass response from Cout
                const hpOut = f / Math.sqrt(f * f + fcOut * fcOut);

                // Low-pass response from transistor HF limitations
                const lpHF = fH / Math.sqrt(f * f + fH * fH);

                // Gain transition due to Ce bypass (only in full bypass mode)
                let gain;
                if (bypassMode === 'full' && fcBypass > 0) {
                    const bypassFactor = f / Math.sqrt(f * f + fcBypass * fcBypass);
                    gain = gainLF + (gainMB - gainLF) * bypassFactor;
                } else {
                    gain = gainMB;
                }

                const result = inputAtten * gain * outputAtten * hpIn * hpOut * lpHF;
                // Ensure we never return 0 or negative (would cause -Infinity in dB)
                return Math.max(result, 1e-10);
            }

            // Find mid-band gain for normalization
            const midF = Math.sqrt(fLow * fH); // Geometric mean of corners
            const midBandGain = magnitude(Math.min(midF, fH / 10));

            // Create graph
            const graph = new Graph({
                xMin: fMin,
                xMax: fMax,
                yMin: -40,
                yMax: 10
            });

            // Generate response curve (normalized to mid-band = 0dB)
            const normFactor = midBandGain > 0 ? midBandGain : 1;
            const curve = generateResponseCurve(fMin, fMax, f => magnitude(f) / normFactor);
            graph.addCurve(curve, { label: 'Response' });

            // Add reference lines
            graph.addHLine(-3, { color: '#f88', label: '-3 dB' });
            graph.addVLine(fLow, { color: '#88f', label: 'fL' });
            if (isFinite(fH) && fH > 0) {
                graph.addVLine(fH, { color: '#8a8', label: 'fH ≈ ' + fmt(fH, 'Hz') });
            }

            return graph.toSVG();
        }

        // Draw input/output waveforms
        function drawWaveforms(params) {
            const { vinPeak, voutPeak, maxSwing, gain } = params;

            // Clipping threshold (peak voltage, not p-p)
            const clipLevel = maxSwing / 2;
            const isClipping = voutPeak > clipLevel;

            const cycles = 2;
            const numPoints = 200;
            const inputPts = [];
            const outputPts = [];

            for (let i = 0; i <= numPoints; i++) {
                const t = (i / numPoints) * cycles;
                const angle = t * 2 * Math.PI;

                // Input: simple sine
                const vin = vinPeak * Math.sin(angle);

                // Output: inverted and amplified, with clipping
                let vout = -voutPeak * Math.sin(angle); // Inverted
                if (isClipping) {
                    vout = Math.max(-clipLevel, Math.min(clipLevel, vout));
                }

                inputPts.push({ x: t, y: vin });
                outputPts.push({ x: t, y: vout });
            }

            const displayedVout = isClipping ? clipLevel : voutPeak;
            let outLabel = `Output (${(displayedVout * 1000).toFixed(0)}mV)`;
            if (isClipping) outLabel += ' CLIPPED';

            const graph = new WaveformGraph({ xLabel: '180° phase inversion' });
            graph.addCurve(inputPts, { color: '#88f', label: `Input (${(vinPeak * 1000).toFixed(0)}mV)` });
            graph.addCurve(outputPts, { color: '#c33', label: outLabel });

            if (isClipping) {
                graph.addHLine(clipLevel, { color: '#c66', label: 'clip' });
                graph.addHLine(-clipLevel, { color: '#c66' });
            }

            return graph.toSVG();
        }

        // Draw DC load line with Q-point and optional AC load line
        function drawLoadLine(params) {
            const { vcc, rc, re, ic, vce, veMin, rload, vceSat: vceSatParam } = params;
            const vceSat = vceSatParam || 0.3;

            // DC Load line endpoints
            const icSat = vcc / (rc + re); // mA at saturation
            const vceCutoff = vcc;

            // AC load line (only if there's a load resistor)
            const hasAcLoad = rload && isFinite(rload) && rload > 0;
            const rac = hasAcLoad ? (rc * rload) / (rc + rload) : rc;

            // AC load line through Q-point with slope -1/Rac
            const acIcAtVce0 = ic + vce / rac;
            const acVceAtIc0 = vce + ic * rac;

            // Calculate swing limits
            const swingDown = vce - vceSat;
            const swingUp = (vcc - veMin) - vce;
            const swing = Math.min(swingDown, swingUp);

            // Set axis ranges
            const xMax = Math.max(vceCutoff, acVceAtIc0) * 1.1;
            const yMax = Math.max(icSat, acIcAtVce0) * 1.1;

            const graph = new LoadLineGraph({ xMax, yMax });

            // Saturation region
            graph.addRegion(0, vceSat, { color: '#fee', label: 'Saturation' });

            // DC Load line
            graph.addLine(0, icSat, vceCutoff, 0, { label: 'DC Load Line' });

            // AC Load line (if there's a load)
            if (hasAcLoad) {
                const acX2 = Math.min(acVceAtIc0, xMax);
                const acY1 = Math.min(acIcAtVce0, yMax);
                graph.addLine(0, acY1, acX2, 0, {
                    color: '#e80',
                    dashed: true,
                    label: 'AC Load Line'
                });
            }

            // Q-point
            graph.addQPoint(vce, ic, { detail: `(${vce.toFixed(1)}V, ${ic.toFixed(2)}mA)` });

            // Swing markers
            if (swing > 0) {
                const vceSwingLow = vce - swing;
                const vceSwingHigh = vce + swing;
                graph.addVLine(vceSwingLow, { color: '#3a3' });
                graph.addVLine(vceSwingHigh, { color: '#3a3' });
                graph.addAnnotation(vce, 0.3, `← Swing: ${(swing * 2).toFixed(1)}V p-p →`);
            }

            // Saturation limit line
            graph.addVLine(vceSat, { color: '#c66' });

            return graph.toSVG();
        }

        function calculate() {
            const vcc = parseFloat(document.getElementById('vcc').value);
            const targetGain = parseFloat(document.getElementById('gain').value);
            const vin = parseFloat(document.getElementById('vin').value) / 1000;
            const zsource = parseFloat(document.getElementById('zsource').value);
            const fLow = parseFloat(document.getElementById('fLow').value);
            const rloadInput = document.getElementById('rload').value;
            const rload = rloadInput ? parseFloat(rloadInput) : Infinity;
            const bypassMode = document.getElementById('bypassMode').value;
            const ic = parseFloat(document.getElementById('ic').value) / 1000; // mA to A

            // Get transistor parameters from preset or custom
            const transistor = getTransistorParams();
            const beta = transistor.beta;
            const fT = transistor.ft;
            const vceSat = transistor.vceSat;

            // Biasing: set Ve for stability, calculate operating point
            const ve = Math.max(vcc * 0.1, 1.0);
            const vb = ve + 0.7;
            const reIntrinsic = V_T / ic;

            // Re is fixed by biasing
            const re = ve / ic;

            // Calculate Rc to achieve desired gain
            // Av = Rc / (Re_effective + re')
            // For unbypassed: Re_effective = Re
            // For bypassed: Re_effective = 0 (only re' remains)
            let rc, reEffective;
            if (bypassMode === 'full') {
                // Full bypass: gain is Rc/re', solve for Rc
                rc = targetGain * reIntrinsic;
                reEffective = 0;
            } else {
                // No bypass: gain is Rc/(Re + re'), solve for Rc
                rc = targetGain * (re + reIntrinsic);
                reEffective = re;
            }

            // Check if Rc is feasible
            const vc = vcc - ic * rc;
            const vcMin = ve + vceSat; // Minimum Vc for active region
            let notes = [];

            if (vc < vcMin) {
                // Rc is too large, clamp it
                rc = (vcc - vcMin) / ic;
                const actualGain = rc / (reEffective + reIntrinsic);
                notes.push('Gain limited to ' + actualGain.toFixed(1) + 'x. To achieve higher gain: increase Vcc, increase Ic, or use bypass mode.');
            }

            // Bias resistors
            const ib = ic / beta;
            const idivider = ib * 10;
            const rtotal = vcc / idivider;
            const r2 = (vb / vcc) * rtotal;
            const r1 = rtotal - r2;

            // Round resistors to E24 values
            const r1Rounded = roundToE24(r1);
            const r2Rounded = roundToE24(r2);
            const rcRounded = roundToE24(rc);
            const reRounded = roundToE24(re);

            // Calculate actual transistor gain with rounded values
            const reEffectiveRounded = bypassMode === 'full' ? 0 : reRounded;
            const transGain = rcRounded / (reEffectiveRounded + reIntrinsic);

            // Input impedance depends on what's in the emitter
            const zinBase = beta * (reEffectiveRounded + reIntrinsic);
            const zin = parallel(r1Rounded, r2Rounded, zinBase);

            // Output impedance is approximately Rc
            const zout = rcRounded;

            // Attenuation factors
            const inputAtten = zsource > 0 ? zin / (zin + zsource) : 1;
            const outputAtten = isFinite(rload) ? rload / (rload + rcRounded) : 1;

            // Effective gain (what you actually get)
            const effectiveGain = inputAtten * transGain * outputAtten;
            const voutPeak = vin * effectiveGain;

            // Capacitors
            const fcorner = fLow / 10;
            const cinCalc = 1 / (2 * Math.PI * fcorner * zin);
            const coutCalc = isFinite(rload) ? 1 / (2 * Math.PI * fcorner * rload) : 1e-6;
            const ceCalc = bypassMode === 'full' ? 10 / (2 * Math.PI * fLow * reRounded) : 0;

            const cinRounded = roundCap(cinCalc);
            const coutRounded = roundCap(coutCalc);
            const ceRounded = ceCalc > 0 ? roundCap(ceCalc) : 0;

            // Recalculate Vc with rounded Rc
            const vcActual = vcc - ic * rcRounded;
            const swingUp = vcc - vcActual;
            const swingDown = vcActual - vcMin;
            const maxSwing = Math.min(swingUp, swingDown) * 2;

            // Warnings
            const warn = document.getElementById('warning');
            let warnings = [];
            if (vcActual < vcMin) {
                warnings.push('<b>Biasing problem:</b> Vc (' + vcActual.toFixed(1) + 'V) is too close to Ve (' + ve.toFixed(1) + 'V). The transistor needs voltage headroom between collector and emitter to amplify. Try lowering the gain, increasing Vcc, or using bypass mode.');
            } else if (voutPeak * 2 > maxSwing) {
                warnings.push('<b>Clipping warning:</b> Your expected output (' + (voutPeak * 2).toFixed(2) + 'V p-p) exceeds the available swing (' + maxSwing.toFixed(2) + 'V p-p). The output waveform will be distorted. Try reducing the input level or lowering the gain.');
            }
            if (warnings.length > 0) {
                warn.innerHTML = warnings.join('<br><br>');
                warn.classList.remove('hidden');
            } else {
                warn.classList.add('hidden');
            }

            // Results
            document.getElementById('results').style.display = 'block';

            // Draw schematic
            document.getElementById('schematic').innerHTML = drawSchematic({
                r1: fmt(r1Rounded, 'Ω'),
                r2: fmt(r2Rounded, 'Ω'),
                rc: fmt(rcRounded, 'Ω'),
                re: fmt(reRounded, 'Ω'),
                cin: fmt(cinRounded, 'F'),
                cout: fmt(coutRounded, 'F'),
                ce: ceRounded > 0 ? fmt(ceRounded, 'F') : null,
                rload: isFinite(rload) ? fmt(rload, 'Ω') : null,
                vb: fmt(vb, 'V'),
                ve: fmt(ve, 'V'),
                vc: fmt(vcActual, 'V'),
                ic: fmt(ic * 1000, 'mA'),
                swing: fmt(maxSwing, 'V') + ' p-p',
                transGain: transGain.toFixed(1) + 'x',
                effectiveGain: effectiveGain.toFixed(1) + 'x',
                bypassMode: bypassMode
            });

            // Table values
            document.getElementById('r1').textContent = fmtLong(r1Rounded, 'Ω');
            document.getElementById('r2').textContent = fmtLong(r2Rounded, 'Ω');
            document.getElementById('rc').textContent = fmtLong(rcRounded, 'Ω');
            document.getElementById('re').textContent = fmtLong(reRounded, 'Ω');
            document.getElementById('cin').textContent = fmtLong(cinRounded, 'F');
            document.getElementById('cout').textContent = fmtLong(coutRounded, 'F');
            document.getElementById('ce').textContent = ceRounded > 0 ? fmtLong(ceRounded, 'F') : 'not used';
            document.getElementById('note').textContent = notes.join(' ');

            // Gain analysis
            document.getElementById('zin').textContent = fmtLong(zin, 'Ω');
            document.getElementById('zout').textContent = fmtLong(zout, 'Ω');
            document.getElementById('transGain').textContent = transGain.toFixed(1) + 'x';
            document.getElementById('inputAtten').textContent = zsource > 0 ? (inputAtten * 100).toFixed(1) + '%' : '100% (no source Z)';
            document.getElementById('outputAtten').textContent = isFinite(rload) ? (outputAtten * 100).toFixed(1) + '%' : '100% (no load)';
            document.getElementById('effectiveGain').textContent = effectiveGain.toFixed(1) + 'x';
            document.getElementById('expectedOut').textContent = (voutPeak * 1000).toFixed(0) + ' mV peak';

            // Draw input/output waveforms
            document.getElementById('waveforms').innerHTML = drawWaveforms({
                vinPeak: vin,
                voutPeak: voutPeak,
                maxSwing: maxSwing,
                gain: effectiveGain
            });

            // Draw DC load line (and AC load line if there's a load)
            document.getElementById('loadLine').innerHTML = drawLoadLine({
                vcc: vcc,
                rc: rcRounded / 1000, // Convert to kΩ for mA calculation
                re: reRounded / 1000,
                ic: ic * 1000, // Convert A to mA
                vce: vcActual - ve, // Vce = Vc - Ve
                veMin: ve,
                rload: isFinite(rload) ? rload / 1000 : null, // Convert to kΩ
                vceSat: vceSat
            });

            // Draw frequency response
            document.getElementById('freqResponse').innerHTML = drawFrequencyResponse({
                zin: zin,
                zsource: zsource,
                rc: rcRounded,
                re: reRounded,
                reEffective: reEffectiveRounded,
                reIntrinsic: reIntrinsic,
                rload: rload,
                cin: cinRounded,
                cout: coutRounded,
                ce: ceRounded,
                beta: beta,
                fLow: fLow,
                fT: fT,
                bypassMode: bypassMode
            });

            // Store values for Falstad export
            storeCalcValues({
                vcc: vcc,
                r1: r1Rounded,
                r2: r2Rounded,
                rc: rcRounded,
                re: reRounded,
                cin: cinRounded,
                cout: coutRounded,
                ce: ceRounded,
                rload: rload,
                beta: beta,
                vin: vin
            });

            // Update step-by-step design calculations
            updateDesignSteps({
                vcc, ve, vb, ic, re, reRounded, reIntrinsic, rc, rcRounded,
                vcActual, vcMin,
                beta, ib, idivider, rtotal, r1, r2, r1Rounded, r2Rounded,
                zinBase, zin, zsource, rload, fLow, fcorner,
                cinCalc, cinRounded, coutCalc, coutRounded, ceCalc, ceRounded,
                bypassMode, targetGain, transGain, inputAtten, outputAtten, effectiveGain
            });
        }
        function resetDefaults() {
            document.getElementById('vcc').value = '10';
            document.getElementById('gain').value = '5';
            document.getElementById('vin').value = '100';
            document.getElementById('zsource').value = '0';
            document.getElementById('fLow').value = '20';
            document.getElementById('rload').value = '';
            document.getElementById('bypassMode').value = 'none';
            document.getElementById('ic').value = '1';
            document.getElementById('transistorPreset').value = 'ideal';
            updateTransistorFields();
        }

        // Store last calculated values for Falstad export
        let lastCalcValues = null;

        function storeCalcValues(vals) {
            lastCalcValues = vals;
        }

        function updateDesignSteps(params) {
            const { vcc, ve, vb, ic, re, reRounded, reIntrinsic, rc, rcRounded, vcActual, vcMin,
                    beta, ib, idivider, rtotal, r1, r2, r1Rounded, r2Rounded,
                    zinBase, zin, zsource, rload, fLow, fcorner,
                    cinCalc, cinRounded, coutCalc, coutRounded, ceCalc, ceRounded,
                    bypassMode, targetGain, transGain, inputAtten, outputAtten, effectiveGain } = params;

            // Step 1: DC Operating Point
            document.getElementById('calc-step1').innerHTML =
                `V<sub>E</sub> = max(0.1 × ${vcc}V, 1V) = <b>${ve.toFixed(2)}V</b><br>` +
                `V<sub>B</sub> = ${ve.toFixed(2)}V + 0.7V = <b>${vb.toFixed(2)}V</b>`;

            // Step 2: Emitter Resistor
            document.getElementById('calc-step2').innerHTML =
                `R<sub>E</sub> = ${ve.toFixed(2)}V / ${(ic*1000).toFixed(2)}mA = ${re.toFixed(1)}Ω → <b>${fmtLong(reRounded, 'Ω')}</b> (E24)`;

            // Step 3: Intrinsic Emitter Resistance
            document.getElementById('calc-step3').innerHTML =
                `r<sub>e</sub>' = 26mV / ${(ic*1000).toFixed(2)}mA = <b>${reIntrinsic.toFixed(2)}Ω</b>`;

            // Step 4: Collector Resistor
            if (bypassMode === 'full') {
                document.getElementById('calc-step4').innerHTML =
                    `<i>Using bypass mode:</i><br>` +
                    `R<sub>C</sub> = ${targetGain} × ${reIntrinsic.toFixed(2)}Ω = ${rc.toFixed(1)}Ω → <b>${fmtLong(rcRounded, 'Ω')}</b> (E24)`;
            } else {
                document.getElementById('calc-step4').innerHTML =
                    `<i>No bypass (stable gain):</i><br>` +
                    `R<sub>C</sub> = ${targetGain} × (${fmtLong(reRounded, 'Ω')} + ${reIntrinsic.toFixed(2)}Ω) = ${rc.toFixed(1)}Ω → <b>${fmtLong(rcRounded, 'Ω')}</b> (E24)`;
            }

            // Step 5: Verify Operating Point
            const vcCheck = vcActual > vcMin ? '✓ OK' : '✗ Too low!';
            document.getElementById('calc-step5').innerHTML =
                `V<sub>C</sub> = ${vcc}V - ${(ic*1000).toFixed(2)}mA × ${fmtLong(rcRounded, 'Ω')} = <b>${vcActual.toFixed(2)}V</b><br>` +
                `Check: ${vcActual.toFixed(2)}V > ${ve.toFixed(2)}V + 0.3V = ${vcMin.toFixed(2)}V? <b>${vcCheck}</b>`;

            // Step 6: Bias Resistors
            document.getElementById('calc-step6').innerHTML =
                `I<sub>B</sub> = ${(ic*1000).toFixed(2)}mA / ${beta} = ${(ib*1e6).toFixed(2)}µA<br>` +
                `I<sub>divider</sub> = 10 × ${(ib*1e6).toFixed(2)}µA = ${(idivider*1e6).toFixed(1)}µA<br>` +
                `R<sub>total</sub> = ${vcc}V / ${(idivider*1e6).toFixed(1)}µA = ${(rtotal/1000).toFixed(1)}kΩ<br>` +
                `R<sub>2</sub> = (${vb.toFixed(2)}V / ${vcc}V) × ${(rtotal/1000).toFixed(1)}kΩ = ${(r2/1000).toFixed(2)}kΩ → <b>${fmtLong(r2Rounded, 'Ω')}</b><br>` +
                `R<sub>1</sub> = ${(rtotal/1000).toFixed(1)}kΩ - ${(r2/1000).toFixed(2)}kΩ = ${(r1/1000).toFixed(2)}kΩ → <b>${fmtLong(r1Rounded, 'Ω')}</b>`;

            // Step 7: Input Impedance
            if (bypassMode === 'full') {
                document.getElementById('calc-step7').innerHTML =
                    `Z<sub>in(base)</sub> = ${beta} × ${reIntrinsic.toFixed(2)}Ω = ${fmtLong(zinBase, 'Ω')}<br>` +
                    `Z<sub>in</sub> = ${fmtLong(r1Rounded, 'Ω')} ∥ ${fmtLong(r2Rounded, 'Ω')} ∥ ${fmtLong(zinBase, 'Ω')} = <b>${fmtLong(zin, 'Ω')}</b>`;
            } else {
                document.getElementById('calc-step7').innerHTML =
                    `Z<sub>in(base)</sub> = ${beta} × (${fmtLong(reRounded, 'Ω')} + ${reIntrinsic.toFixed(2)}Ω) = ${fmtLong(zinBase, 'Ω')}<br>` +
                    `Z<sub>in</sub> = ${fmtLong(r1Rounded, 'Ω')} ∥ ${fmtLong(r2Rounded, 'Ω')} ∥ ${fmtLong(zinBase, 'Ω')} = <b>${fmtLong(zin, 'Ω')}</b>`;
            }

            // Step 8: Coupling Capacitors
            const rloadStr = isFinite(rload) ? fmtLong(rload, 'Ω') : '∞';
            const coutStr = isFinite(rload)
                ? `C<sub>out</sub> = 1 / (2π × ${fLow}Hz × ${rloadStr}) = ${fmtLong(coutCalc, 'F')} → <b>${fmtLong(coutRounded, 'F')}</b>`
                : `C<sub>out</sub> = <i>No load specified, using default</i> → <b>${fmtLong(coutRounded, 'F')}</b>`;
            document.getElementById('calc-step8').innerHTML =
                `<i>Using f<sub>corner</sub> = f<sub>low</sub>/10 = ${fcorner.toFixed(1)}Hz for margin:</i><br>` +
                `C<sub>in</sub> = 1 / (2π × ${fcorner.toFixed(1)}Hz × ${fmtLong(zin, 'Ω')}) = ${fmtLong(cinCalc, 'F')} → <b>${fmtLong(cinRounded, 'F')}</b><br>` +
                coutStr;

            // Step 9: Bypass Capacitor
            if (bypassMode === 'full') {
                document.getElementById('calc-step9').innerHTML =
                    `C<sub>E</sub> = 10 / (2π × ${fLow}Hz × ${fmtLong(reRounded, 'Ω')}) = ${fmtLong(ceCalc, 'F')} → <b>${fmtLong(ceRounded, 'F')}</b>`;
            } else {
                document.getElementById('calc-step9').innerHTML =
                    `<i>Bypass not used - gain is stable but lower</i>`;
            }

            // Step 10: Effective Gain
            const inputAttenStr = zsource > 0
                ? `${fmtLong(zin, 'Ω')} / (${fmtLong(zin, 'Ω')} + ${fmtLong(zsource, 'Ω')}) = ${(inputAtten*100).toFixed(1)}%`
                : `100% (no source impedance)`;
            const outputAttenStr = isFinite(rload)
                ? `${fmtLong(rload, 'Ω')} / (${fmtLong(rload, 'Ω')} + ${fmtLong(rcRounded, 'Ω')}) = ${(outputAtten*100).toFixed(1)}%`
                : `100% (no load)`;
            document.getElementById('calc-step10').innerHTML =
                `Input attenuation = ${inputAttenStr}<br>` +
                `Output attenuation = ${outputAttenStr}<br>` +
                `Effective gain = ${transGain.toFixed(2)} × ${(inputAtten).toFixed(3)} × ${(outputAtten).toFixed(3)} = <b>${effectiveGain.toFixed(2)}x</b>`;
        }

        function openInFalstad() {
            if (!lastCalcValues) {
                alert('Please calculate first');
                return;
            }

            const v = lastCalcValues;

            // Build schematic for Falstad export
            const sch = new Schematic(500, 350);
            sch.setFalstadOptions({ vMax: v.vcc * 2 });

            // Components - CE amplifier layout
            // Vcc rail at top
            sch.place('power', 'Vcc', 256, 48, { value: v.vcc });

            // Bias resistors
            sch.place('resistor-v', 'R1', 160, 88, { value: v.r1 });
            sch.place('resistor-v', 'R2', 160, 176, { value: v.r2 });
            sch.place('ground', 'GND1', 160, 224);

            // Collector resistor
            sch.place('resistor-v', 'Rc', 256, 88, { value: v.rc });

            // NPN transistor
            sch.place('npn', 'Q1', 208, 128, { beta: v.beta });

            // Emitter resistor
            sch.place('resistor-v', 'Re', 233, 184, { value: v.re });
            sch.place('ground', 'GND2', 233, 232);

            // Input AC source and coupling cap
            sch.place('ac-source-h', 'Vin', 48, 128, { value: v.vin, freq: 1000 });
            sch.place('capacitor-h', 'Cin', 104, 128, { value: v.cin });

            // Output coupling cap
            sch.place('capacitor-h', 'Cout', 312, 112, { value: v.cout });

            // Output probe
            sch.place('probe', 'Out', 360, 112);

            // Wiring
            // Vcc to R1 and Rc
            sch.wire('Vcc.a', 'R1.a');
            sch.wire('Vcc.a', 'Rc.a');

            // Bias network
            sch.wire('R1.b', 'R2.a');
            sch.wire('R2.b', 'GND1.a');

            // Base connection
            sch.wire('Vin.b', 'Cin.a');
            sch.wire('Cin.b', 'R1.b');
            sch.wire('R1.b', 'Q1.base');

            // Collector to Rc and output
            sch.wire('Rc.b', 'Q1.collector');
            sch.wire('Rc.b', 'Cout.a');
            sch.wire('Cout.b', 'Out.a');

            // Emitter to Re
            sch.wire('Q1.emitter', 'Re.a');
            sch.wire('Re.b', 'GND2.a');

            // Add bypass capacitor if used
            if (v.ce > 0) {
                sch.place('capacitor-v', 'Ce', 280, 184, { value: v.ce });
                sch.wire('Q1.emitter', 'Ce.a');
                sch.wire('Ce.b', 'Re.b');
            }

            // Add load resistor if specified
            if (v.rload && isFinite(v.rload)) {
                sch.place('resistor-v', 'Rload', 360, 160, { value: v.rload });
                sch.place('ground', 'GND3', 360, 208);
                sch.wire('Out.a', 'Rload.a');
                sch.wire('Rload.b', 'GND3.a');
            }

            sch.openInFalstad();
        }

        window.onload = function() {
            updateTransistorFields();
            calculate();
        };
    </script>
</body>
</html>
