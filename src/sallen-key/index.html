<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sallen-Key Filter Calculator</title>
    <style>
        .combined-schematic {
            overflow-x: auto;
            padding: 10px;
            border: 1px solid #ccc;
            background: #fafafa;
            margin: 10px 0;
        }
        .component-tables {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 10px 0;
        }
        .stage-values {
            padding: 10px;
            border: 1px solid #ddd;
            background: #fafafa;
        }
        .stage-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        table {
            border-collapse: collapse;
            margin: 10px 0;
        }
        td, th {
            padding: 4px 12px 4px 0;
            text-align: left;
        }
        .component-table td:nth-child(2) {
            font-family: monospace;
        }
        #response {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Sallen-Key Filter Calculator</h1>

    <h2>Inputs</h2>
    <table>
        <tr>
            <td>Filter type:</td>
            <td>
                <select id="filterType" onchange="calculate()">
                    <option value="lowpass">Lowpass</option>
                    <option value="highpass">Highpass</option>
                </select>
            </td>
        </tr>
        <tr>
            <td>Response:</td>
            <td>
                <select id="responseType" onchange="updateRippleVisibility(); calculate()">
                    <option value="butterworth">Butterworth (maximally flat)</option>
                    <option value="chebyshev">Chebyshev Type I (steeper rolloff)</option>
                </select>
            </td>
        </tr>
        <tr id="rippleRow" style="display: none;">
            <td>Passband ripple:</td>
            <td>
                <select id="ripple" onchange="calculate()">
                    <option value="0.5">0.5 dB</option>
                    <option value="1" selected>1 dB</option>
                    <option value="2">2 dB</option>
                    <option value="3">3 dB</option>
                </select>
            </td>
        </tr>
        <tr>
            <td>Order:</td>
            <td>
                <select id="order" onchange="calculate()">
                    <option value="2">2nd order (-12 dB/oct)</option>
                    <option value="4">4th order (-24 dB/oct)</option>
                    <option value="6">6th order (-36 dB/oct)</option>
                    <option value="8">8th order (-48 dB/oct)</option>
                </select>
            </td>
        </tr>
        <tr>
            <td>Cutoff frequency:</td>
            <td><input type="number" id="fc" value="1000" step="100" min="1" onchange="calculate()"> Hz</td>
        </tr>
        <tr>
            <td>Capacitor value:</td>
            <td><input type="number" id="cval" value="10" step="1" min="1" onchange="calculate()"> nF</td>
        </tr>
        <tr>
            <td>Supply voltage (+/-):</td>
            <td><input type="number" id="vcc" value="12" step="1" min="5" onchange="calculate()"> V</td>
        </tr>
    </table>

    <div id="warning" style="color: red; display: none; margin-top: 10px;"></div>

    <div id="results">
        <h2>Filter Summary</h2>
        <table>
            <tr><td>Type:</td><td id="summaryType"></td></tr>
            <tr><td>Order:</td><td id="summaryOrder"></td></tr>
            <tr><td>Cutoff frequency:</td><td id="summaryFc"></td></tr>
            <tr><td>Rolloff:</td><td id="summaryRolloff"></td></tr>
            <tr><td>Total gain:</td><td id="summaryGain"></td></tr>
        </table>

        <h2>Stages</h2>
        <div id="stages"></div>

        <h2>Frequency Response</h2>
        <div id="response"></div>
    </div>

    <script src="../common.js"></script>
    <script src="../schematic.js"></script>
    <script>
        // Draw a single stage into an existing schematic at x offset
        function drawStageAt(sch, stage, vcc, xOff, stageIdx, isFirst, isLast) {
            const isLowpass = stage.type === 'lowpass';
            const Rval = fmt(stage.R, 'Ω');
            const Cval = fmt(stage.C, 'F');
            const prefix = 'S' + stageIdx + '_';

            // Signal path at y=70, feedback at y=25
            const sigY = 70;
            const fbY = 25;

            // Op-amp at local x=330
            sch.place('opamp', prefix + 'U', xOff + 330, 90, { flip: true });

            // Z1, Z2: Series elements from input to + input
            if (isLowpass) {
                sch.place('resistor-h', prefix + 'Z1', xOff + 50, sigY, { label: Rval });
                sch.place('resistor-h', prefix + 'Z2', xOff + 140, sigY, { label: Rval });
            } else {
                sch.place('capacitor-h', prefix + 'Z1', xOff + 50, sigY, { label: Cval });
                sch.place('capacitor-h', prefix + 'Z2', xOff + 140, sigY, { label: Cval });
            }

            // Z3: Feedback from Vx to output
            if (isLowpass) {
                sch.place('capacitor-h', prefix + 'Z3', xOff + 240, fbY, { label: Cval });
            } else {
                sch.place('resistor-h', prefix + 'Z3', xOff + 240, fbY, { label: Rval });
            }

            // Z4: Shunt from V+ node to ground
            if (isLowpass) {
                sch.place('capacitor-v', prefix + 'Z4', xOff + 210, 120, { label: Cval });
                sch.place('ground', prefix + 'GND1', xOff + 210, 145);
            } else {
                sch.place('resistor-v', prefix + 'Z4', xOff + 210, 140, { label: Rval });
                sch.place('ground', prefix + 'GND1', xOff + 210, 185);
            }

            // Gain network
            sch.place('resistor-v', prefix + 'Ra', xOff + 260, 230, { label: fmt(stage.Ra, 'Ω') });
            sch.place('ground', prefix + 'GND2', xOff + 260, 275);
            if (stage.Rb > 0) {
                sch.place('resistor-h', prefix + 'Rb', xOff + 340, 195, { label: fmt(stage.Rb, 'Ω') });
            }

            // --- Wiring ---

            // Input connection
            if (isFirst) {
                sch.label('In', xOff + 5, sigY + 4);
            }
            sch.wire({ x: xOff + 20, y: sigY }, prefix + 'Z1.a');

            // Z1 -> Vx -> Z2
            sch.wire(prefix + 'Z1.b', { x: xOff + 95, y: sigY });
            sch.wire({ x: xOff + 95, y: sigY }, prefix + 'Z2.a');
            sch.node(xOff + 95, sigY);

            // Z2 -> V+ node -> wire to op-amp plus
            sch.wire(prefix + 'Z2.b', { x: xOff + 210, y: sigY });
            sch.node(xOff + 210, sigY);
            sch.wire({ x: xOff + 210, y: sigY }, prefix + 'U.plus');

            // Z3 feedback: Vx up to Z3, Z3 across to output
            sch.wire({ x: xOff + 95, y: sigY }, { x: xOff + 95, y: fbY });
            sch.wire({ x: xOff + 95, y: fbY }, prefix + 'Z3.a');
            sch.wire(prefix + 'Z3.b', { x: xOff + 410, y: fbY });
            sch.wire({ x: xOff + 410, y: fbY }, { x: xOff + 410, y: 90 });

            // Z4 shunt: V+ down to Z4, Z4 to ground
            sch.wire({ x: xOff + 210, y: sigY }, { x: xOff + 210, y: 116 });
            sch.wire(prefix + 'Z4.b', prefix + 'GND1.a');

            // Gain network wiring
            sch.wire(prefix + 'U.minus', { x: xOff + 260, y: 110 }, { route: 'v-h' });
            sch.wire({ x: xOff + 260, y: 110 }, { x: xOff + 260, y: 195 });
            sch.node(xOff + 260, 195);
            sch.wire({ x: xOff + 260, y: 195 }, prefix + 'Ra.a');
            sch.wire(prefix + 'Ra.b', prefix + 'GND2.a');

            if (stage.Rb > 0) {
                sch.wire({ x: xOff + 260, y: 195 }, prefix + 'Rb.a');
                sch.wire(prefix + 'Rb.b', { x: xOff + 410, y: 195 });
                sch.wire({ x: xOff + 410, y: 90 }, { x: xOff + 410, y: 195 });
            } else {
                sch.wire({ x: xOff + 260, y: 195 }, { x: xOff + 410, y: 195 });
                sch.wire({ x: xOff + 410, y: 90 }, { x: xOff + 410, y: 195 });
                sch.label('(wire)', xOff + 335, 190, { anchor: 'middle' });
            }

            // Output from op-amp
            sch.wire(prefix + 'U.out', { x: xOff + 430, y: 90 });
            sch.node(xOff + 410, 90);

            // Output label only on last stage
            if (isLast) {
                sch.label('Out', xOff + 435, 94);
            }

            // Power rails
            sch.wire(prefix + 'U.vpos', { x: xOff + 330, y: 45 });
            sch.label('+' + vcc + 'V', xOff + 340, 42);
            sch.wire(prefix + 'U.vneg', { x: xOff + 330, y: 135 });
            sch.label('−' + vcc + 'V', xOff + 340, 150);

            // Stage label
            sch.label('Stage ' + stage.stageNum, xOff + 200, 295, { anchor: 'middle', bold: true });
            sch.label('Q=' + stage.Q.toFixed(2) + ' K=' + stage.K.toFixed(2), xOff + 200, 308, { anchor: 'middle' });
        }

        // Calculate magnitude response of a single 2nd-order stage at frequency f
        function stageMagnitude(stage, f) {
            const w = f / stage.fcActual;  // Normalized frequency
            const w2 = w * w;
            const denom = Math.sqrt(Math.pow(1 - w2, 2) + Math.pow(w / stage.Q, 2));

            if (stage.type === 'lowpass') {
                return stage.K / denom;
            } else {
                return stage.K * w2 / denom;
            }
        }

        // Calculate total filter magnitude response at frequency f
        function filterMagnitude(stages, f) {
            let mag = 1;
            for (const stage of stages) {
                mag *= stageMagnitude(stage, f);
            }
            return mag;
        }

        // Draw frequency response plot
        function drawFrequencyResponse(stages, responseType, rippleDb, targetFc) {
            const width = 600;
            const height = 300;
            const margin = { top: 20, right: 30, bottom: 40, left: 50 };
            const plotW = width - margin.left - margin.right;
            const plotH = height - margin.top - margin.bottom;

            // Frequency range: 2 decades below to 2 decades above fc
            const fc = targetFc;
            const fMin = fc / 100;
            const fMax = fc * 100;

            // dB range
            const dbMin = -60;
            const dbMax = 20;

            // Find normalization factor (peak gain in passband)
            const isLowpass = stages[0].type === 'lowpass';
            let maxMag = 0;
            for (let i = 0; i <= 100; i++) {
                const f = isLowpass
                    ? fMin + (fc - fMin) * i / 100
                    : fc + (fMax - fc) * i / 100;
                const mag = filterMagnitude(stages, f);
                if (mag > maxMag) maxMag = mag;
            }
            if (maxMag === 0) maxMag = 1; // Fallback

            // Generate response data points (normalized to 0 dB peak)
            const points = [];
            const numPoints = 200;
            for (let i = 0; i <= numPoints; i++) {
                const logF = Math.log10(fMin) + (Math.log10(fMax) - Math.log10(fMin)) * i / numPoints;
                const f = Math.pow(10, logF);
                const mag = filterMagnitude(stages, f) / maxMag;
                const db = 20 * Math.log10(mag);
                points.push({ f, db: Math.max(dbMin, Math.min(dbMax, db)) });
            }

            // Coordinate transforms
            const xScale = (f) => margin.left + plotW * (Math.log10(f) - Math.log10(fMin)) / (Math.log10(fMax) - Math.log10(fMin));
            const yScale = (db) => margin.top + plotH * (dbMax - db) / (dbMax - dbMin);

            let svg = `<svg width="${width}" height="${height}" style="font-family: monospace; font-size: 11px;">`;

            // Background
            svg += `<rect x="${margin.left}" y="${margin.top}" width="${plotW}" height="${plotH}" fill="#fafafa" stroke="#ccc"/>`;

            // Grid lines - vertical (frequency decades)
            for (let decade = Math.ceil(Math.log10(fMin)); decade <= Math.floor(Math.log10(fMax)); decade++) {
                const f = Math.pow(10, decade);
                const x = xScale(f);
                svg += `<line x1="${x}" y1="${margin.top}" x2="${x}" y2="${margin.top + plotH}" stroke="#ddd" stroke-width="1"/>`;
                svg += `<text x="${x}" y="${height - 5}" text-anchor="middle">${fmt(f, 'Hz')}</text>`;
            }

            // Grid lines - horizontal (dB)
            for (let db = dbMin; db <= dbMax; db += 10) {
                const y = yScale(db);
                svg += `<line x1="${margin.left}" y1="${y}" x2="${margin.left + plotW}" y2="${y}" stroke="#ddd" stroke-width="1"/>`;
                svg += `<text x="${margin.left - 5}" y="${y + 4}" text-anchor="end">${db}</text>`;
            }

            // Reference lines depend on filter type
            if (responseType === 'chebyshev') {
                // For Chebyshev, show 0dB and -ripple lines (passband bounds)
                const y0db = yScale(0);
                const yRipple = yScale(-rippleDb);
                svg += `<line x1="${margin.left}" y1="${y0db}" x2="${margin.left + plotW}" y2="${y0db}" stroke="#8a8" stroke-width="1" stroke-dasharray="4,2"/>`;
                svg += `<line x1="${margin.left}" y1="${yRipple}" x2="${margin.left + plotW}" y2="${yRipple}" stroke="#f88" stroke-width="1" stroke-dasharray="4,2"/>`;
            } else {
                // For Butterworth, show -3dB line
                const y3db = yScale(-3);
                svg += `<line x1="${margin.left}" y1="${y3db}" x2="${margin.left + plotW}" y2="${y3db}" stroke="#f88" stroke-width="1" stroke-dasharray="4,2"/>`;
            }

            // Cutoff frequency marker
            const xFc = xScale(fc);
            svg += `<line x1="${xFc}" y1="${margin.top}" x2="${xFc}" y2="${margin.top + plotH}" stroke="#88f" stroke-width="1" stroke-dasharray="4,2"/>`;

            // Response curve
            let pathD = `M ${xScale(points[0].f)} ${yScale(points[0].db)}`;
            for (let i = 1; i < points.length; i++) {
                pathD += ` L ${xScale(points[i].f)} ${yScale(points[i].db)}`;
            }
            svg += `<path d="${pathD}" fill="none" stroke="#2266cc" stroke-width="2"/>`;

            // Axis labels
            svg += `<text x="${width / 2}" y="${height - 22}" text-anchor="middle">Frequency</text>`;
            svg += `<text x="15" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 15, ${height / 2})">Gain (dB)</text>`;

            // Legend
            svg += `<line x1="${margin.left + 10}" y1="${margin.top + 12}" x2="${margin.left + 30}" y2="${margin.top + 12}" stroke="#88f" stroke-dasharray="4,2"/>`;
            svg += `<text x="${margin.left + 35}" y="${margin.top + 16}">fc = ${fmt(fc, 'Hz')}</text>`;
            if (responseType === 'chebyshev') {
                svg += `<line x1="${margin.left + 130}" y1="${margin.top + 12}" x2="${margin.left + 150}" y2="${margin.top + 12}" stroke="#f88" stroke-dasharray="4,2"/>`;
                svg += `<text x="${margin.left + 155}" y="${margin.top + 16}">-${rippleDb} dB</text>`;
            } else {
                svg += `<line x1="${margin.left + 130}" y1="${margin.top + 12}" x2="${margin.left + 150}" y2="${margin.top + 12}" stroke="#f88" stroke-dasharray="4,2"/>`;
                svg += `<text x="${margin.left + 155}" y="${margin.top + 16}">-3 dB</text>`;
            }

            svg += '</svg>';
            return svg;
        }

        // Draw all stages in a single horizontal schematic
        function drawAllStages(stages, vcc) {
            const stageWidth = 450;
            const margin = 30;
            const totalWidth = margin + stages.length * stageWidth + margin;
            const sch = new Schematic(totalWidth, 320);

            for (let i = 0; i < stages.length; i++) {
                const xOff = margin + i * stageWidth;
                const isFirst = i === 0;
                const isLast = i === stages.length - 1;
                drawStageAt(sch, stages[i], vcc, xOff, i, isFirst, isLast);

                // Wire between stages (output of this stage to input of next)
                if (!isLast) {
                    const nextXOff = margin + (i + 1) * stageWidth;
                    sch.wire({ x: xOff + 430, y: 90 }, { x: nextXOff + 20, y: 70 }, { route: 'h-v' });
                }
            }

            return sch.toSVG();
        }

        function updateRippleVisibility() {
            const response = document.getElementById('responseType').value;
            document.getElementById('rippleRow').style.display = response === 'chebyshev' ? '' : 'none';
        }

        function calculate() {
            const filterType = document.getElementById('filterType').value;
            const responseType = document.getElementById('responseType').value;
            const order = parseInt(document.getElementById('order').value);
            const fc = parseFloat(document.getElementById('fc').value);
            const cInput = parseFloat(document.getElementById('cval').value) * 1e-9;
            const vcc = parseFloat(document.getElementById('vcc').value);
            const rippleDb = parseFloat(document.getElementById('ripple').value);

            const C = roundCap(cInput);

            let stages;
            if (responseType === 'chebyshev') {
                stages = chebyshevFilter(filterType, order, fc, C, rippleDb);
            } else {
                stages = butterworthFilter(filterType, order, fc, C);
            }

            if (!stages) {
                document.getElementById('warning').textContent = 'Invalid order selected';
                document.getElementById('warning').style.display = 'block';
                return;
            }

            // Check for warnings
            let warnings = [];
            for (const stage of stages) {
                if (stage.R > 1e6) {
                    warnings.push(`Stage ${stage.stageNum}: R too high (${fmtLong(stage.R, 'Ω')}). Try larger C.`);
                }
                if (stage.R < 100) {
                    warnings.push(`Stage ${stage.stageNum}: R too low (${fmtLong(stage.R, 'Ω')}). Try smaller C.`);
                }
            }

            const warn = document.getElementById('warning');
            if (warnings.length > 0) {
                warn.innerHTML = warnings.join('<br>');
                warn.style.display = 'block';
            } else {
                warn.style.display = 'none';
            }

            // Calculate total gain
            const totalGain = stages.reduce((g, s) => g * s.K, 1);

            // Summary
            const responseLabel = responseType === 'chebyshev'
                ? `Chebyshev (${rippleDb} dB ripple)`
                : 'Butterworth';
            document.getElementById('summaryType').textContent =
                filterType.charAt(0).toUpperCase() + filterType.slice(1) + ' / ' + responseLabel;
            document.getElementById('summaryOrder').textContent = order + ' (' + stages.length + ' stage' + (stages.length > 1 ? 's' : '') + ')';
            document.getElementById('summaryFc').textContent = fmtLong(stages[0].fcActual, 'Hz');
            document.getElementById('summaryRolloff').textContent = '-' + (order * 6) + ' dB/octave (-' + (order * 20) + ' dB/decade)';
            document.getElementById('summaryGain').textContent = totalGain.toFixed(2) + ' V/V (' + (20 * Math.log10(totalGain)).toFixed(1) + ' dB)';

            // Draw combined schematic
            const stagesDiv = document.getElementById('stages');
            stagesDiv.innerHTML = '';

            const schematicDiv = document.createElement('div');
            schematicDiv.className = 'combined-schematic';
            schematicDiv.innerHTML = drawAllStages(stages, vcc);
            stagesDiv.appendChild(schematicDiv);

            // Component values table
            const tableDiv = document.createElement('div');
            tableDiv.className = 'component-tables';

            for (const stage of stages) {
                const stageDiv = document.createElement('div');
                stageDiv.className = 'stage-values';

                const title = document.createElement('div');
                title.className = 'stage-title';
                title.textContent = 'Stage ' + stage.stageNum + ' (Q = ' + stage.targetQ.toFixed(4) + ')';
                stageDiv.appendChild(title);

                const table = document.createElement('table');
                table.className = 'component-table';
                table.innerHTML = `
                    <tr><td>R (x2):</td><td>${fmtLong(stage.R, 'Ω')}</td></tr>
                    <tr><td>C (x2):</td><td>${fmtLong(stage.C, 'F')}</td></tr>
                    <tr><td>Ra:</td><td>${fmtLong(stage.Ra, 'Ω')}</td></tr>
                    <tr><td>Rb:</td><td>${stage.Rb > 0 ? fmtLong(stage.Rb, 'Ω') : 'wire (0)'}</td></tr>
                    <tr><td>Gain (K):</td><td>${stage.K.toFixed(3)}</td></tr>
                    <tr><td>Actual Q:</td><td>${stage.Q.toFixed(3)}</td></tr>
                    <tr><td>Actual fc:</td><td>${fmtLong(stage.fcActual, 'Hz')}</td></tr>
                `;
                stageDiv.appendChild(table);

                tableDiv.appendChild(stageDiv);
            }

            stagesDiv.appendChild(tableDiv);

            // Draw frequency response
            const responseDiv = document.getElementById('response');
            responseDiv.innerHTML = drawFrequencyResponse(stages, responseType, rippleDb, fc);
        }

        window.onload = calculate;
    </script>
</body>
</html>
